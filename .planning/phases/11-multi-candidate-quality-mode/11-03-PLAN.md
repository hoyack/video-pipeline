---
phase: 11-multi-candidate-quality-mode
plan: 03
type: execute
wave: 3
depends_on: ["11-01", "11-02"]
files_modified:
  - backend/vidpipe/api/routes.py
  - frontend/src/api/types.ts
  - frontend/src/api/client.ts
  - frontend/src/components/GenerateForm.tsx
  - frontend/src/components/SceneCard.tsx
  - frontend/src/components/ProjectDetail.tsx
  - frontend/src/lib/constants.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/projects/{id}/scenes/{idx}/candidates returns all candidates with scores"
    - "PUT /api/projects/{id}/scenes/{idx}/candidates/{cid}/select deselects current winner, selects new one, AND updates VideoClip.local_path"
    - "GenerateForm has Quality Mode toggle with candidate count selector (2-4) and cost multiplier display"
    - "SceneCard shows candidate comparison when quality mode project has multiple candidates"
    - "User can click a candidate to manually override auto-selection"
  artifacts:
    - path: "backend/vidpipe/api/routes.py"
      provides: "GET candidates and PUT select endpoints"
      contains: "list_candidates"
    - path: "frontend/src/api/types.ts"
      provides: "CandidateScore TypeScript interface"
      contains: "CandidateScore"
    - path: "frontend/src/components/GenerateForm.tsx"
      provides: "Quality Mode toggle with cost impact"
      contains: "quality_mode"
    - path: "frontend/src/components/SceneCard.tsx"
      provides: "Candidate comparison panel within scene card"
      contains: "CandidateComparison"
    - path: "frontend/src/components/ProjectDetail.tsx"
      provides: "Passes projectId and qualityMode props to SceneCard"
      contains: "qualityMode"
  key_links:
    - from: "frontend/src/components/ProjectDetail.tsx"
      to: "frontend/src/components/SceneCard.tsx"
      via: "projectId and qualityMode props passed to SceneCard"
      pattern: "qualityMode.*SceneCard|SceneCard.*qualityMode"
    - from: "frontend/src/components/SceneCard.tsx"
      to: "/api/projects/{id}/scenes/{idx}/candidates"
      via: "fetch in useEffect when quality_mode project"
      pattern: "candidates"
    - from: "backend/vidpipe/api/routes.py"
      to: "backend/vidpipe/db/models.py"
      via: "GenerationCandidate query and VideoClip update"
      pattern: "GenerationCandidate|VideoClip"
---

<objective>
Add candidate API endpoints, Quality Mode controls in GenerateForm, and candidate comparison display in SceneCard so users can enable Quality Mode, view scored candidates, and manually override auto-selection.

Purpose: Complete the user-facing integration — everything built in Plans 01-02 becomes visible and controllable.
Output: Two API endpoints, extended GenerateForm, candidate comparison in SceneCard.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-multi-candidate-quality-mode/11-RESEARCH.md
@.planning/phases/11-multi-candidate-quality-mode/11-01-SUMMARY.md
@.planning/phases/11-multi-candidate-quality-mode/11-02-SUMMARY.md
@backend/vidpipe/api/routes.py
@backend/vidpipe/db/models.py
@frontend/src/api/types.ts
@frontend/src/api/client.ts
@frontend/src/components/GenerateForm.tsx
@frontend/src/components/SceneCard.tsx
@frontend/src/components/ProjectDetail.tsx
@frontend/src/lib/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Candidate API endpoints and response schemas</name>
  <files>backend/vidpipe/api/routes.py</files>
  <action>
Add two new endpoints and their Pydantic response schemas to routes.py.

**Pydantic schemas (add near other response models):**

```python
class CandidateResponse(BaseModel):
    """Response schema for a single generation candidate."""
    candidate_id: str
    candidate_number: int
    local_path: Optional[str] = None
    manifest_adherence_score: Optional[float] = None
    visual_quality_score: Optional[float] = None
    continuity_score: Optional[float] = None
    prompt_adherence_score: Optional[float] = None
    composite_score: Optional[float] = None
    scoring_details: Optional[dict] = None
    is_selected: bool = False
    selected_by: str = "auto"
    generation_cost: float = 0.0
    scoring_cost: float = 0.0
    created_at: str
```

**Endpoint 1: GET /api/projects/{project_id}/scenes/{scene_idx}/candidates**

```python
@router.get("/projects/{project_id}/scenes/{scene_idx}/candidates")
async def list_candidates(project_id: str, scene_idx: int):
    """List all generation candidates for a specific scene with scores."""
    async with async_session() as session:
        result = await session.execute(
            select(GenerationCandidate)
            .where(
                GenerationCandidate.project_id == uuid.UUID(project_id),
                GenerationCandidate.scene_index == scene_idx,
            )
            .order_by(GenerationCandidate.candidate_number)
        )
        candidates = result.scalars().all()
        return [
            CandidateResponse(
                candidate_id=str(c.id),
                candidate_number=c.candidate_number,
                local_path=c.local_path,
                manifest_adherence_score=c.manifest_adherence_score,
                visual_quality_score=c.visual_quality_score,
                continuity_score=c.continuity_score,
                prompt_adherence_score=c.prompt_adherence_score,
                composite_score=c.composite_score,
                scoring_details=c.scoring_details,
                is_selected=c.is_selected,
                selected_by=c.selected_by,
                generation_cost=c.generation_cost,
                scoring_cost=c.scoring_cost,
                created_at=str(c.created_at),
            )
            for c in candidates
        ]
```

**Endpoint 2: PUT /api/projects/{project_id}/scenes/{scene_idx}/candidates/{candidate_id}/select**

```python
@router.put("/projects/{project_id}/scenes/{scene_idx}/candidates/{candidate_id}/select")
async def select_candidate(project_id: str, scene_idx: int, candidate_id: str):
    """Manually override auto-selection for a scene's candidate.

    CRITICAL: Updates BOTH GenerationCandidate.is_selected AND VideoClip.local_path.
    The stitcher reads VideoClip.local_path, so both must be consistent.
    """
    async with async_session() as session:
        # Load all candidates for this scene
        all_result = await session.execute(
            select(GenerationCandidate).where(
                GenerationCandidate.project_id == uuid.UUID(project_id),
                GenerationCandidate.scene_index == scene_idx,
            )
        )
        all_candidates = all_result.scalars().all()
        if not all_candidates:
            raise HTTPException(404, "No candidates found for this scene")

        # Find the chosen candidate
        chosen = next(
            (c for c in all_candidates if str(c.id) == candidate_id),
            None,
        )
        if not chosen:
            raise HTTPException(404, "Candidate not found")

        # Deselect all, then select chosen
        for c in all_candidates:
            c.is_selected = False
        chosen.is_selected = True
        chosen.selected_by = "user"

        # CRITICAL: Update VideoClip.local_path to point to selected candidate
        scene_result = await session.execute(
            select(Scene).where(
                Scene.project_id == uuid.UUID(project_id),
                Scene.scene_index == scene_idx,
            )
        )
        scene = scene_result.scalar_one_or_none()
        if scene:
            clip_result = await session.execute(
                select(VideoClip).where(VideoClip.scene_id == scene.id)
            )
            clip = clip_result.scalar_one_or_none()
            if clip:
                clip.local_path = chosen.local_path

        await session.commit()
        return {"selected": candidate_id, "selected_by": "user"}
```

Add `from vidpipe.db.models import GenerationCandidate` to the imports at the top of routes.py (alongside existing model imports).

Also add `GenerationCandidate` to the import line that already imports `Project, Scene, Keyframe, VideoClip, Manifest, Asset, SceneManifest as SceneManifestModel`.
  </action>
  <verify>
Run `python -c "from vidpipe.api.routes import router; routes = [r.path for r in router.routes]; print([r for r in routes if 'candidates' in r])"` to confirm both endpoints are registered.
  </verify>
  <done>
GET /api/projects/{id}/scenes/{idx}/candidates returns all candidates with scores. PUT select endpoint deselects current winner, marks new one, AND updates VideoClip.local_path for stitcher consistency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend Quality Mode toggle and candidate comparison UI</name>
  <files>
    frontend/src/api/types.ts
    frontend/src/api/client.ts
    frontend/src/components/GenerateForm.tsx
    frontend/src/components/SceneCard.tsx
    frontend/src/components/ProjectDetail.tsx
    frontend/src/lib/constants.ts
  </files>
  <action>
**types.ts additions:**

Add CandidateScore interface:
```typescript
/** Candidate score data from GET /api/projects/{id}/scenes/{idx}/candidates */
export interface CandidateScore {
  candidate_id: string;
  candidate_number: number;
  local_path: string | null;
  manifest_adherence_score: number | null;
  visual_quality_score: number | null;
  continuity_score: number | null;
  prompt_adherence_score: number | null;
  composite_score: number | null;
  is_selected: boolean;
  selected_by: string;
  generation_cost: number;
  scoring_cost: number;
}
```

Add quality_mode and candidate_count to GenerateRequest:
```typescript
export interface GenerateRequest {
  // ... existing fields ...
  quality_mode?: boolean;
  candidate_count?: number;
}
```

Add quality_mode and candidate_count to ProjectDetail:
```typescript
export interface ProjectDetail {
  // ... existing fields ...
  quality_mode?: boolean;
  candidate_count?: number;
}
```

**client.ts additions:**

```typescript
/** GET /api/projects/{id}/scenes/{idx}/candidates */
export function listCandidates(
  projectId: string,
  sceneIdx: number,
): Promise<CandidateScore[]> {
  return request<CandidateScore[]>(
    `/api/projects/${projectId}/scenes/${sceneIdx}/candidates`,
  );
}

/** PUT /api/projects/{id}/scenes/{idx}/candidates/{cid}/select */
export function selectCandidate(
  projectId: string,
  sceneIdx: number,
  candidateId: string,
): Promise<{ selected: string; selected_by: string }> {
  return request<{ selected: string; selected_by: string }>(
    `/api/projects/${projectId}/scenes/${sceneIdx}/candidates/${candidateId}/select`,
    { method: "PUT" },
  );
}
```

Add the new types to the import statement in client.ts.

**constants.ts addition:**

Add a cost multiplier helper or note in the estimateCost function. If quality_mode is on, video generation cost multiplies by candidate_count. Add a simple function:

```typescript
/** Estimate quality mode cost multiplier */
export function qualityModeCostMultiplier(candidateCount: number): number {
  return candidateCount;  // Linear scaling — N candidates = Nx video gen cost
}
```

**GenerateForm.tsx changes:**

Add state for quality mode:
```typescript
const [qualityMode, setQualityMode] = useState(false);
const [candidateCount, setCandidateCount] = useState(2);
```

After the audio toggle section (or before the Generate button), add a Quality Mode section:

```tsx
{/* Quality Mode */}
<div className="rounded-lg border border-gray-800 bg-gray-900/50 p-4">
  <div className="flex items-center justify-between">
    <div>
      <label className="text-sm font-medium text-gray-200">Quality Mode</label>
      <p className="text-xs text-gray-500 mt-0.5">
        Generate multiple candidates per scene and auto-select the best
      </p>
    </div>
    <button
      type="button"
      onClick={() => setQualityMode(!qualityMode)}
      className={clsx(
        "relative inline-flex h-6 w-11 items-center rounded-full transition-colors",
        qualityMode ? "bg-amber-600" : "bg-gray-700"
      )}
    >
      <span
        className={clsx(
          "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
          qualityMode ? "translate-x-6" : "translate-x-1"
        )}
      />
    </button>
  </div>

  {qualityMode && (
    <div className="mt-3 space-y-2">
      <div className="flex items-center gap-3">
        <label className="text-xs text-gray-400">Candidates per scene:</label>
        <div className="flex gap-1">
          {[2, 3, 4].map((n) => (
            <button
              key={n}
              type="button"
              onClick={() => setCandidateCount(n)}
              className={clsx(
                "px-3 py-1 rounded text-xs font-medium transition-colors",
                candidateCount === n
                  ? "bg-amber-600 text-white"
                  : "bg-gray-800 text-gray-400 hover:bg-gray-700"
              )}
            >
              {n}x
            </button>
          ))}
        </div>
      </div>
      <div className="flex items-center gap-2 text-xs">
        <span className="text-gray-500">Cost impact:</span>
        <span className="text-amber-400 font-medium">
          ~{candidateCount}x video generation cost
          {" "}(${(cost * candidateCount).toFixed(2)} est.)
        </span>
      </div>
    </div>
  )}
</div>
```

Update the handleSubmit to include quality_mode and candidate_count in the request body:
```typescript
const body = {
  // ... existing fields ...
  quality_mode: qualityMode,
  candidate_count: qualityMode ? candidateCount : undefined,
};
```

Use `?? undefined` pattern (not `?? null`) to omit candidate_count from JSON when not in quality mode, following existing pattern from Phase 6 (manifest_id).

**SceneCard.tsx changes:**

Add a CandidateComparison section that appears when the project has quality mode candidates. This requires:

1. Accept projectId and qualityMode as optional props:
```typescript
export function SceneCard({
  scene,
  defaultExpanded = false,
  projectId,
  qualityMode = false,
}: {
  scene: SceneDetail;
  defaultExpanded?: boolean;
  projectId?: string;
  qualityMode?: boolean;
}) {
```

2. Add state and effect for loading candidates:
```typescript
const [candidates, setCandidates] = useState<CandidateScore[]>([]);
const [candidatesLoaded, setCandidatesLoaded] = useState(false);

useEffect(() => {
  if (qualityMode && projectId && expanded && !candidatesLoaded) {
    listCandidates(projectId, scene.scene_index)
      .then(setCandidates)
      .then(() => setCandidatesLoaded(true))
      .catch(() => {});  // Non-critical — scene card still shows normally
  }
}, [qualityMode, projectId, expanded, candidatesLoaded, scene.scene_index]);
```

3. Inside the expanded section (where keyframes/clips are shown), add a candidate comparison panel when candidates exist:

```tsx
{candidates.length > 1 && (
  <div className="mt-3 border-t border-gray-800 pt-3">
    <h4 className="text-[10px] font-semibold uppercase tracking-wide text-gray-500 mb-2">
      Quality Mode — {candidates.length} Candidates
    </h4>
    <div className="grid grid-cols-2 gap-2 lg:grid-cols-4">
      {candidates.map((c) => (
        <button
          key={c.candidate_id}
          onClick={(e) => {
            e.stopPropagation();
            if (!c.is_selected && projectId) {
              selectCandidate(projectId, scene.scene_index, c.candidate_id)
                .then(() => {
                  setCandidates((prev) =>
                    prev.map((p) => ({
                      ...p,
                      is_selected: p.candidate_id === c.candidate_id,
                      selected_by: p.candidate_id === c.candidate_id ? "user" : p.selected_by,
                    }))
                  );
                })
                .catch(() => {});
            }
          }}
          className={clsx(
            "rounded-lg border p-2 text-left transition-colors text-xs",
            c.is_selected
              ? "border-amber-500 bg-amber-500/10"
              : "border-gray-800 bg-gray-900/50 hover:border-gray-700"
          )}
        >
          <div className="flex items-center justify-between mb-1">
            <span className="font-medium text-gray-300">
              Take {c.candidate_number + 1}
            </span>
            {c.is_selected && (
              <span className="text-[9px] font-bold uppercase text-amber-400">
                {c.selected_by === "user" ? "User Pick" : "Best"}
              </span>
            )}
          </div>
          {c.composite_score != null && (
            <div className="text-lg font-bold text-gray-200 mb-1">
              {c.composite_score.toFixed(1)}
            </div>
          )}
          <div className="space-y-0.5 text-[10px] text-gray-500">
            {c.manifest_adherence_score != null && (
              <div className="flex justify-between">
                <span>Manifest</span>
                <span className="text-gray-400">{c.manifest_adherence_score.toFixed(1)}</span>
              </div>
            )}
            {c.visual_quality_score != null && (
              <div className="flex justify-between">
                <span>Quality</span>
                <span className="text-gray-400">{c.visual_quality_score.toFixed(1)}</span>
              </div>
            )}
            {c.continuity_score != null && (
              <div className="flex justify-between">
                <span>Continuity</span>
                <span className="text-gray-400">{c.continuity_score.toFixed(1)}</span>
              </div>
            )}
            {c.prompt_adherence_score != null && (
              <div className="flex justify-between">
                <span>Prompt</span>
                <span className="text-gray-400">{c.prompt_adherence_score.toFixed(1)}</span>
              </div>
            )}
          </div>
        </button>
      ))}
    </div>
  </div>
)}
```

4. Import the needed functions and types at the top of SceneCard.tsx:
```typescript
import { listCandidates, selectCandidate } from "../api/client.ts";
import type { CandidateScore } from "../api/types.ts";
```

5. Add `useEffect` import if not already present.

**ProjectDetail.tsx changes:**

In ProjectDetail.tsx, pass `projectId` and `qualityMode` props to SceneCard when rendering scenes:
```tsx
<SceneCard
  key={scene.scene_index}
  scene={scene}
  projectId={project.project_id}
  qualityMode={project.quality_mode}
/>
```

Read ProjectDetail.tsx first to find where SceneCard is rendered, then add the two props. Without this change, SceneCard never receives the props and the candidate comparison panel will never activate.
  </action>
  <verify>
1. `cd /home/ubuntu/work/video-pipeline/frontend && npx tsc --noEmit` — TypeScript compilation passes
2. `python -c "from vidpipe.api.routes import router; routes = [r.path for r in router.routes]; assert any('candidates' in r for r in routes); print('API OK')"` — endpoints registered
3. Inspect GenerateForm.tsx for quality_mode toggle and cost display
4. Inspect SceneCard.tsx for candidate comparison grid
5. Inspect ProjectDetail.tsx for `qualityMode` and `projectId` props passed to SceneCard
  </verify>
  <done>
GET/PUT candidate endpoints working. GenerateForm has Quality Mode toggle with candidate count (2-4) pills and cost multiplier display. SceneCard loads and displays candidate comparison grid with scores when expanded in a quality mode project. Users can click a candidate card to override auto-selection. VideoClip.local_path updated on manual selection. ProjectDetail.tsx passes projectId and qualityMode props to SceneCard so the candidate panel activates.
  </done>
</task>

</tasks>

<verification>
1. Backend: `python -c "from vidpipe.api.routes import router; print([r.path for r in router.routes if 'candidate' in r.path])"` — both candidate endpoints exist
2. Frontend: `cd /home/ubuntu/work/video-pipeline/frontend && npx tsc --noEmit` — no TypeScript errors
3. Types: grep types.ts for CandidateScore interface
4. GenerateForm: grep GenerateForm.tsx for quality_mode
5. SceneCard: grep SceneCard.tsx for CandidateComparison or candidates
6. ProjectDetail: grep ProjectDetail.tsx for qualityMode — confirms props are passed to SceneCard
</verification>

<success_criteria>
- GET /api/projects/{id}/scenes/{idx}/candidates returns scored candidates
- PUT select updates both is_selected AND VideoClip.local_path
- GenerateForm shows Quality Mode toggle, candidate count selector (2/3/4), and cost multiplier
- SceneCard displays candidate comparison grid when quality mode project has candidates
- Manual override sends PUT request and updates local UI optimistically
- ProjectDetail.tsx passes projectId and qualityMode to SceneCard
- TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/11-multi-candidate-quality-mode/11-03-SUMMARY.md`
</output>
