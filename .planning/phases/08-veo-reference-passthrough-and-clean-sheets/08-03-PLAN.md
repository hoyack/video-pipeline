---
phase: 08-veo-reference-passthrough-and-clean-sheets
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - backend/vidpipe/api/routes.py
  - frontend/src/api/types.ts
  - frontend/src/components/SceneCard.tsx
autonomous: true

must_haves:
  truths:
    - "SceneCard displays which 3 reference images were selected for each scene"
    - "Reference badges show asset thumbnail, manifest_tag, and quality score"
    - "Reference data flows from backend API through to frontend component"
    - "Scenes without references show no reference section (backward compatible)"
  artifacts:
    - path: "backend/vidpipe/api/routes.py"
      provides: "SceneDetail response includes selected_references array"
      contains: "selected_references"
    - path: "frontend/src/api/types.ts"
      provides: "SceneDetail and SceneReference TypeScript types"
      contains: "SceneReference"
    - path: "frontend/src/components/SceneCard.tsx"
      provides: "Reference badge display in scene cards"
      contains: "Identity References"
  key_links:
    - from: "frontend/src/components/SceneCard.tsx"
      to: "frontend/src/api/types.ts"
      via: "imports SceneReference type"
      pattern: "SceneReference"
    - from: "backend/vidpipe/api/routes.py"
      to: "backend/vidpipe/db/models.py"
      via: "queries SceneManifest.selected_reference_tags and Asset table"
      pattern: "selected_reference_tags"
---

<objective>
Add reference image display to the SceneCard frontend component, showing which 3 asset references were selected per scene. Extend the backend API to include selected reference data in scene detail responses.

Purpose: Users can see which identity references Veo 3.1 used for each scene, enabling debugging and quality assessment.
Output: Enhanced SceneDetail API response with reference data, SceneCard with reference badges.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-veo-reference-passthrough-and-clean-sheets/08-01-SUMMARY.md
@backend/vidpipe/api/routes.py
@frontend/src/api/types.ts
@frontend/src/components/SceneCard.tsx
@backend/vidpipe/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend API SceneDetail response with selected reference data</name>
  <files>backend/vidpipe/api/routes.py</files>
  <action>
1. Add a new Pydantic response model `SceneReference` near the existing SceneDetail class:

```python
class SceneReference(BaseModel):
    """Asset reference selected for a scene's Veo generation."""
    asset_id: str
    manifest_tag: str
    name: str
    asset_type: str
    thumbnail_url: Optional[str] = None
    reference_image_url: Optional[str] = None
    quality_score: Optional[float] = None
    is_face_crop: bool = False
```

2. Add `selected_references: list[SceneReference] = []` field to the existing SceneDetail class (after the existing fields). Default to empty list for backward compatibility.

3. In the `get_project_detail` route handler (the one that builds SceneDetail objects), after the existing scene_details construction loop, add reference resolution:

Import SceneManifest model at top: `from vidpipe.db.models import ... SceneManifest as SceneManifestModel`

After building scene_details list, query scene manifests for all scenes at once:
```python
# Load selected reference tags for all scenes (Phase 8)
sm_result = await session.execute(
    select(SceneManifestModel).where(
        SceneManifestModel.project_id == project.id
    )
)
scene_manifests_by_index = {
    sm.scene_index: sm for sm in sm_result.scalars().all()
}

# If project has manifest, load assets for reference resolution
ref_assets_by_tag = {}
if project.manifest_id:
    assets_result = await session.execute(
        select(Asset).where(Asset.manifest_id == project.manifest_id)
    )
    ref_assets_by_tag = {
        a.manifest_tag: a for a in assets_result.scalars().all()
    }

# Enrich scene_details with selected references
for sd in scene_details:
    sm = scene_manifests_by_index.get(sd.scene_index)
    if sm and sm.selected_reference_tags:
        refs = []
        for tag in sm.selected_reference_tags:
            asset = ref_assets_by_tag.get(tag)
            if asset:
                refs.append(SceneReference(
                    asset_id=str(asset.id),
                    manifest_tag=asset.manifest_tag,
                    name=asset.name,
                    asset_type=asset.asset_type,
                    thumbnail_url=asset.thumbnail_url,
                    reference_image_url=asset.reference_image_url,
                    quality_score=asset.quality_score,
                    is_face_crop=asset.is_face_crop,
                ))
        sd.selected_references = refs
```

This is efficient: one query for all scene manifests, one query for all assets, then in-memory join. No N+1 queries.
  </action>
  <verify>
Run: `python -c "from vidpipe.api.routes import SceneDetail, SceneReference; print('SceneReference fields:', list(SceneReference.model_fields.keys())); print('selected_references in SceneDetail:', 'selected_references' in SceneDetail.model_fields)"` -- confirms both models exist with correct fields.

Run: `grep -c 'selected_references' backend/vidpipe/api/routes.py` -- should show multiple occurrences (model field, population logic).

Run: `grep 'SceneManifestModel' backend/vidpipe/api/routes.py` -- confirms SceneManifest import and usage.
  </verify>
  <done>API SceneDetail response includes selected_references array populated from SceneManifest.selected_reference_tags and resolved against Asset table. Empty array for scenes without references (backward compatible).</done>
</task>

<task type="auto">
  <name>Task 2: Add reference badges to frontend SceneCard component</name>
  <files>frontend/src/api/types.ts, frontend/src/components/SceneCard.tsx</files>
  <action>
**1. Update `frontend/src/api/types.ts`:**

Add a new `SceneReference` interface (after existing SceneDetail):

```typescript
/** Reference image selected for a scene's video generation */
export interface SceneReference {
  asset_id: string;
  manifest_tag: string;
  name: string;
  asset_type: string;
  thumbnail_url: string | null;
  reference_image_url: string | null;
  quality_score: number | null;
  is_face_crop: boolean;
}
```

Add `selected_references?: SceneReference[]` field to the existing SceneDetail interface.

**2. Update `frontend/src/components/SceneCard.tsx`:**

Import `SceneReference` from types. The component already receives `scene: SceneDetail` which will now include `selected_references`.

Add a reference badges section inside the expanded area, after the keyframe thumbnails section and before the prompt sections. Only render when `scene.selected_references` exists and has items:

```tsx
{/* Identity References (Phase 8) */}
{expanded && scene.selected_references && scene.selected_references.length > 0 && (
  <div className="mt-2">
    <span className="text-[10px] font-semibold uppercase tracking-wide text-gray-500">
      Identity References
    </span>
    <div className="mt-1 flex gap-2">
      {scene.selected_references.map((ref) => (
        <div
          key={ref.asset_id}
          className="flex items-center gap-1.5 rounded border border-gray-700 bg-gray-800/50 px-2 py-1"
          title={ref.name}
        >
          {(ref.thumbnail_url || ref.reference_image_url) && (
            <img
              src={ref.thumbnail_url || ref.reference_image_url || ""}
              alt={ref.manifest_tag}
              className="h-6 w-6 rounded object-cover"
              loading="lazy"
            />
          )}
          <span className="text-[10px] font-medium text-blue-400">
            {ref.manifest_tag}
          </span>
          {ref.quality_score != null && (
            <span className="text-[10px] text-gray-500">
              {ref.quality_score.toFixed(1)}
            </span>
          )}
        </div>
      ))}
    </div>
  </div>
)}
```

Place this section inside the `{expanded && (...)}` block, specifically after the keyframe image section and before the PromptSection components. This keeps the visual hierarchy: keyframes -> references -> prompts -> clip.

The badges use the same design language as existing SceneCard elements: gray-800 bg, gray-700 border, 10px uppercase labels, blue-400 for tag text (consistent with the project's link/accent color).
  </action>
  <verify>
Run: `cd /home/ubuntu/work/video-pipeline/frontend && npx tsc --noEmit 2>&1 | head -20` -- TypeScript compilation should pass with no type errors related to SceneReference.

Run: `grep 'SceneReference' frontend/src/api/types.ts` -- confirms interface exists.

Run: `grep 'selected_references' frontend/src/components/SceneCard.tsx` -- confirms reference badges render.

Run: `grep 'Identity References' frontend/src/components/SceneCard.tsx` -- confirms label text.
  </verify>
  <done>SceneCard displays reference badges with asset thumbnail, manifest_tag (e.g. CHAR_01), and quality score for each selected reference. Badges only appear when scene has selected_references (backward compatible for non-manifest projects).</done>
</task>

</tasks>

<verification>
- Backend: `python -c "from vidpipe.api.routes import SceneDetail, SceneReference; print(SceneDetail.model_fields.keys())"` includes selected_references
- Frontend: `cd /home/ubuntu/work/video-pipeline/frontend && npx tsc --noEmit` passes
- SceneCard renders "Identity References" section only when selected_references is non-empty
- Scenes without manifest data show no reference section (existing UI unchanged)
</verification>

<success_criteria>
1. API returns SceneReference objects in SceneDetail.selected_references
2. SceneCard shows up to 3 reference badges with thumbnail, tag, and quality score
3. Non-manifest projects and scenes without references show no reference UI
4. TypeScript types match backend response schema
</success_criteria>

<output>
After completion, create `.planning/phases/08-veo-reference-passthrough-and-clean-sheets/08-03-SUMMARY.md`
</output>
