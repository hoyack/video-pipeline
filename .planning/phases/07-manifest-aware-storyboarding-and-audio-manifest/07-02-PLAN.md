---
phase: 07-manifest-aware-storyboarding-and-audio-manifest
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - backend/vidpipe/pipeline/storyboard.py
  - backend/vidpipe/services/manifest_service.py
autonomous: true

must_haves:
  truths:
    - "When project.manifest_id is set, storyboard LLM receives asset registry context with tags, reverse_prompts, and quality scores"
    - "Storyboard output includes per-scene SceneManifest with asset placements referencing manifest tags"
    - "Per-scene SceneAudioManifest generated with dialogue mapped to character tags, SFX, ambient, and music"
    - "Scene manifests and audio manifests persisted to scene_manifests and scene_audio_manifests tables"
    - "LLM can declare NEW assets not in registry via new_asset_declarations field"
    - "Projects without manifest_id use existing storyboard behavior unchanged (backward compatible)"
    - "Asset tag references in placements are post-validated against registry and warnings logged for unrecognized tags"
  artifacts:
    - path: "backend/vidpipe/pipeline/storyboard.py"
      provides: "Enhanced storyboard generation with manifest context and manifest persistence"
      exports: ["generate_storyboard"]
    - path: "backend/vidpipe/services/manifest_service.py"
      provides: "Asset loading and formatting functions for LLM context injection"
      exports: ["load_manifest_assets", "format_asset_registry"]
  key_links:
    - from: "backend/vidpipe/pipeline/storyboard.py"
      to: "backend/vidpipe/services/manifest_service.py"
      via: "load_manifest_assets call when project.manifest_id is set"
      pattern: "load_manifest_assets.*manifest_id"
    - from: "backend/vidpipe/pipeline/storyboard.py"
      to: "backend/vidpipe/schemas/storyboard_enhanced.py"
      via: "Uses EnhancedStoryboardOutput as Gemini response_schema"
      pattern: "EnhancedStoryboardOutput"
    - from: "backend/vidpipe/pipeline/storyboard.py"
      to: "backend/vidpipe/db/models.py"
      via: "Creates SceneManifest and SceneAudioManifest records"
      pattern: "SceneManifest\\(|SceneAudioManifest\\("
    - from: "backend/vidpipe/pipeline/storyboard.py"
      to: "backend/vidpipe/schemas/storyboard.py"
      via: "Falls back to original StoryboardOutput when no manifest"
      pattern: "StoryboardOutput"
---

<objective>
Enhance the storyboard pipeline to consume Asset Registry context when a manifest is attached, produce structured scene and audio manifests, and persist them to the database. Maintain full backward compatibility for projects without manifests.

Purpose: This is the core integration that bridges asset preparation (Phase 5-6) with generation (Phase 8+). The storyboard LLM now understands what assets exist and plans scenes around them, producing structured placement data that downstream phases can consume for reference selection and prompt rewriting.

Output: Enhanced storyboard.py with conditional manifest-aware behavior, plus asset loading/formatting utilities in manifest_service.py.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-manifest-aware-storyboarding-and-audio-manifest/07-RESEARCH.md
@.planning/phases/07-manifest-aware-storyboarding-and-audio-manifest/07-01-SUMMARY.md
@backend/vidpipe/pipeline/storyboard.py
@backend/vidpipe/services/manifest_service.py
@backend/vidpipe/schemas/storyboard.py
@backend/vidpipe/schemas/storyboard_enhanced.py
@backend/vidpipe/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add asset loading and formatting functions to manifest_service</name>
  <files>backend/vidpipe/services/manifest_service.py</files>
  <action>
Add two new functions to `backend/vidpipe/services/manifest_service.py`:

1. **`load_manifest_assets(session, manifest_id) -> list[Asset]`** — Async function that loads all assets for a manifest ordered by quality_score descending (nulls last). Uses existing query pattern from list_assets but with quality-based ordering. This is a separate function from list_assets because the ordering differs (list_assets orders by sort_order, this orders by quality for LLM context priority).

```python
async def load_manifest_assets(
    session: AsyncSession,
    manifest_id: uuid.UUID,
) -> list[Asset]:
    """Load all assets for a manifest, ordered by quality score descending.

    Used for LLM context injection where highest-quality assets should
    appear first in the system prompt for better attention distribution.

    Args:
        session: Active database session
        manifest_id: Manifest UUID

    Returns:
        List of Asset instances ordered by quality_score desc (nulls last)
    """
    result = await session.execute(
        select(Asset)
        .where(Asset.manifest_id == manifest_id)
        .order_by(Asset.quality_score.desc().nullslast())
    )
    return list(result.scalars().all())
```

2. **`format_asset_registry(assets) -> str`** — Synchronous function that formats a list of Asset objects into a structured text block for LLM system prompt injection. For each asset, include:
   - Header line: `[{manifest_tag}] "{name}" ({asset_type}, quality: {quality_score:.1f}/10)` (use "N/A" if quality_score is None)
   - Reverse prompt: Truncated to first 200 chars with "..." suffix if longer. Skip if None.
   - Production notes (visual_description): Truncated to first 150 chars. Only include for assets with quality_score >= 7.0 (to keep context window manageable per Research pitfall 1).
   - Blank line between assets

Wrap the asset list with:
- Header: "AVAILABLE ASSETS FOR THIS PROJECT:" followed by a separator line ("━" * 40)
- Footer: separator line + "Reference assets by [TAG]. You may declare NEW assets not in the registry."

If the assets list is empty, return: "No assets registered. Describe all visual elements in scenes."

Follow the exact pattern from the Research doc code examples section.
  </action>
  <verify>
Run: `cd /home/ubuntu/work/video-pipeline/backend && python -c "
from vidpipe.services.manifest_service import load_manifest_assets, format_asset_registry
print('load_manifest_assets imported OK')
print('format_asset_registry imported OK')

# Test format with empty list
result = format_asset_registry([])
assert 'No assets registered' in result, f'Empty case failed: {result}'
print('Empty format OK:', result[:50])

# Test with mock asset object
class MockAsset:
    manifest_tag = 'CHAR_01'
    name = 'Detective Marcus'
    asset_type = 'CHARACTER'
    quality_score = 8.5
    reverse_prompt = 'A weathered middle-aged man with salt-and-pepper beard'
    visual_description = 'Signature trench coat always present'

result = format_asset_registry([MockAsset()])
assert '[CHAR_01]' in result
assert 'Detective Marcus' in result
assert '8.5/10' in result
print('Mock format OK')
print(result)
"`
  </verify>
  <done>load_manifest_assets and format_asset_registry import successfully. format_asset_registry returns "No assets registered..." for empty list. For a list of assets, it produces formatted text with [TAG] headers, truncated reverse_prompts, and production notes for high-quality assets only.</done>
</task>

<task type="auto">
  <name>Task 2: Enhance storyboard generation with manifest context and manifest persistence</name>
  <files>backend/vidpipe/pipeline/storyboard.py</files>
  <action>
Modify `backend/vidpipe/pipeline/storyboard.py` to conditionally use manifest-aware storyboarding when project.manifest_id is set, while preserving exact existing behavior for projects without manifests.

**Changes to make:**

1. **Add imports** at the top:
   - `import logging`
   - `from vidpipe.schemas.storyboard_enhanced import EnhancedStoryboardOutput`
   - `from vidpipe.services.manifest_service import load_manifest_assets, format_asset_registry`
   - `from vidpipe.db.models import SceneManifest as SceneManifestModel, SceneAudioManifest as SceneAudioManifestModel`
   - Add `logger = logging.getLogger(__name__)` after imports

2. **Add enhanced system prompt** as a new constant `ENHANCED_STORYBOARD_PROMPT`. This should be the existing STORYBOARD_SYSTEM_PROMPT content PLUS these additional sections inserted before "REQUIREMENTS:":

```
AVAILABLE ASSETS (from Asset Registry):
{asset_registry_block}

SCENE MANIFEST INSTRUCTIONS:
When creating scenes, generate a scene_manifest for each scene:
- Reference registered assets by their [TAG] (e.g., [CHAR_01], [ENV_02])
- Use the asset's reverse_prompt for visual detail — it's already optimized for generation
- Assign roles: subject, background, prop, interaction_target, environment
- Specify spatial positions and actions for each placed asset
- Include composition metadata: shot_type, camera_movement, focal_point
- Add continuity_notes describing visual continuity with previous scenes
- You MAY declare new_asset_declarations for assets NOT in the registry — describe them textually with name, type, and description

AUDIO MANIFEST INSTRUCTIONS:
For each scene, generate an audio_manifest with:
- dialogue_lines: Map speech to character tags (speaker_tag must be a registered [TAG] like CHAR_01). Include delivery notes (muttered, shouted, whispered) and timing (start, mid-scene, end)
- sfx: Sound effects with trigger descriptions and relative timing. Use "SFX:" mental model
- ambient: Base layer soundscape + environmental context. Describe what you HEAR, not see
- music: Style, mood, tempo, instruments, and transition cues (fade in, cut, swell)
- audio_continuity: What carries from previous scene, what's new, what cuts
```

Also update the REQUIREMENTS section in the enhanced prompt to include:
```
- Each scene MUST include scene_manifest with at least one asset placement
- Each scene MUST include audio_manifest (even if minimal — at least ambient)
- Asset tag references MUST match tags from the Available Assets list above
- Character wardrobe notes in placements MUST be consistent with character descriptions
```

3. **Modify `generate_storyboard` function** with conditional logic:

At the start of the function, after getting model_id and client:

```python
# Determine if manifest-aware mode
use_manifests = project.manifest_id is not None

if use_manifests:
    # Load asset registry for LLM context
    assets = await load_manifest_assets(session, project.manifest_id)
    asset_registry_block = format_asset_registry(assets)
    asset_tags_set = {a.manifest_tag for a in assets}
    logger.info(
        "Project %s: manifest-aware storyboard with %d assets",
        project.id, len(assets)
    )
else:
    asset_registry_block = ""
    asset_tags_set = set()
```

For prompt building, if use_manifests is True, use ENHANCED_STORYBOARD_PROMPT with asset_registry_block format substitution. If False, use existing STORYBOARD_SYSTEM_PROMPT. The format call for enhanced adds `asset_registry_block=asset_registry_block` alongside existing style and aspect_ratio.

For the Gemini call, if use_manifests is True, use `response_schema=EnhancedStoryboardOutput`. If False, use `response_schema=StoryboardOutput` (existing behavior).

For parsing, if use_manifests, parse as `EnhancedStoryboardOutput.model_validate_json(response.text)`. Otherwise, parse as `StoryboardOutput.model_validate_json(response.text)` (existing).

4. **After creating Scene records** (existing code), add manifest persistence when use_manifests is True:

```python
if use_manifests:
    for scene_data in storyboard.scenes:
        # Post-validate asset tags
        for placement in scene_data.scene_manifest.placements:
            if placement.asset_tag not in asset_tags_set:
                logger.warning(
                    "Project %s scene %d: unrecognized asset tag '%s' "
                    "(not in registry, may be declared as new asset)",
                    project.id, scene_data.scene_index, placement.asset_tag
                )

        # Persist scene manifest
        scene_manifest = SceneManifestModel(
            project_id=project.id,
            scene_index=scene_data.scene_index,
            manifest_json=scene_data.scene_manifest.model_dump(),
            composition_shot_type=scene_data.scene_manifest.composition.shot_type,
            composition_camera_movement=scene_data.scene_manifest.composition.camera_movement,
            asset_tags=[p.asset_tag for p in scene_data.scene_manifest.placements],
            new_asset_count=len(scene_data.scene_manifest.new_asset_declarations or []),
        )
        session.add(scene_manifest)

        # Persist audio manifest
        audio = scene_data.audio_manifest
        audio_manifest = SceneAudioManifestModel(
            project_id=project.id,
            scene_index=scene_data.scene_index,
            dialogue_json=[d.model_dump() for d in audio.dialogue_lines],
            sfx_json=[s.model_dump() for s in audio.sfx],
            ambient_json=audio.ambient.model_dump() if audio.ambient else None,
            music_json=audio.music.model_dump() if audio.music else None,
            audio_continuity_json=audio.audio_continuity.model_dump() if audio.audio_continuity else None,
            speaker_tags=[d.speaker_tag for d in audio.dialogue_lines],
            has_dialogue=len(audio.dialogue_lines) > 0,
            has_music=audio.music is not None,
        )
        session.add(audio_manifest)

    logger.info(
        "Project %s: persisted %d scene manifests and audio manifests",
        project.id, len(storyboard.scenes)
    )
```

5. **The existing code** that sets project.style_guide, project.storyboard_raw, creates Scene records, updates project.status to "keyframing", and commits MUST remain unchanged. The manifest persistence is additive — it happens between Scene creation and the commit.

6. **Important:** The storyboard.style_guide and storyboard.characters fields are the same in both StoryboardOutput and EnhancedStoryboardOutput, so `project.style_guide = storyboard.style_guide.model_dump()` and `project.storyboard_raw = storyboard.model_dump()` work identically for both schemas.

7. **Do NOT change the function signature** — `generate_storyboard(session, project)` stays the same. The manifest-awareness is determined entirely by checking `project.manifest_id`.
  </action>
  <verify>
Run: `cd /home/ubuntu/work/video-pipeline/backend && python -c "
import ast, sys

# Parse the storyboard module to verify structure
with open('vidpipe/pipeline/storyboard.py') as f:
    tree = ast.parse(f.read())

# Check imports
import_names = []
for node in ast.walk(tree):
    if isinstance(node, ast.ImportFrom):
        for alias in node.names:
            import_names.append(alias.name)

assert 'EnhancedStoryboardOutput' in import_names, 'Missing EnhancedStoryboardOutput import'
assert 'load_manifest_assets' in import_names, 'Missing load_manifest_assets import'
assert 'format_asset_registry' in import_names, 'Missing format_asset_registry import'
print('Import checks passed')

# Check that both prompt constants exist
with open('vidpipe/pipeline/storyboard.py') as f:
    content = f.read()

assert 'STORYBOARD_SYSTEM_PROMPT' in content, 'Original prompt missing'
assert 'ENHANCED_STORYBOARD_PROMPT' in content, 'Enhanced prompt missing'
assert 'asset_registry_block' in content, 'Asset registry block missing'
assert 'use_manifests' in content or 'manifest_id' in content, 'Manifest conditional missing'
assert 'SceneManifestModel' in content or 'SceneManifest' in content, 'SceneManifest persistence missing'
assert 'SceneAudioManifestModel' in content or 'SceneAudioManifest' in content, 'SceneAudioManifest persistence missing'
assert 'logger.warning' in content, 'Tag validation warning missing'
print('Content checks passed')

# Verify module imports without errors
from vidpipe.pipeline.storyboard import generate_storyboard
print('generate_storyboard imports OK')
print('All verification checks passed')
"`
  </verify>
  <done>storyboard.py imports EnhancedStoryboardOutput, load_manifest_assets, format_asset_registry. Contains both STORYBOARD_SYSTEM_PROMPT (original) and ENHANCED_STORYBOARD_PROMPT (with asset registry + manifest instructions). generate_storyboard conditionally uses manifest-aware schema when project.manifest_id is set, persists SceneManifest and SceneAudioManifest records, post-validates asset tags with logger.warning for unrecognized tags, and falls back to existing behavior when no manifest is attached.</done>
</task>

</tasks>

<verification>
1. `from vidpipe.services.manifest_service import load_manifest_assets, format_asset_registry` succeeds
2. `from vidpipe.pipeline.storyboard import generate_storyboard` succeeds
3. storyboard.py contains both original and enhanced prompt constants
4. Manifest-aware path uses EnhancedStoryboardOutput as response_schema
5. Non-manifest path uses original StoryboardOutput (backward compatible)
6. SceneManifest and SceneAudioManifest records created only when manifest_id is set
7. Asset tag post-validation logs warnings for unrecognized tags
8. Function signature `generate_storyboard(session, project)` unchanged
9. No changes to Scene record creation or project status transitions
</verification>

<success_criteria>
- Projects WITH manifest_id: storyboard uses EnhancedStoryboardOutput schema, injects asset registry into system prompt, persists scene and audio manifests to database
- Projects WITHOUT manifest_id: storyboard uses original StoryboardOutput schema, no manifest injection, no manifest records created (exact existing behavior)
- Asset tags in placements are validated against registry; unrecognized tags are logged as warnings (not errors)
- generate_storyboard function signature and return type unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/07-manifest-aware-storyboarding-and-audio-manifest/07-02-SUMMARY.md`
</output>
