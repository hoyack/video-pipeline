---
phase: 02-generation-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - vidpipe/pipeline/video_gen.py
autonomous: true

must_haves:
  truths:
    - "Video clips are generated using Veo 3.1 with first-frame and last-frame interpolation"
    - "Long-running operations are polled with exponential backoff until completion or timeout"
    - "Operation ID is persisted before polling begins for idempotent resume"
    - "RAI-filtered clips are marked as rai_filtered and pipeline continues without crashing"
    - "Timed-out operations are marked as timed_out after max polls exceeded"
  artifacts:
    - path: "vidpipe/pipeline/video_gen.py"
      provides: "Veo video generation with polling and error handling"
      exports: ["generate_videos"]
      min_lines: 150
  key_links:
    - from: "vidpipe/pipeline/video_gen.py"
      to: "vidpipe/services/vertex_client.py"
      via: "get_vertex_client() for Veo API calls"
      pattern: "get_vertex_client\\(\\)"
    - from: "vidpipe/pipeline/video_gen.py"
      to: "vidpipe/services/file_manager.py"
      via: "FileManager to save MP4 clips"
      pattern: "FileManager\\(\\)"
    - from: "vidpipe/pipeline/video_gen.py"
      to: "vidpipe.db.models.VideoClip"
      via: "creates and updates VideoClip records during polling"
      pattern: "VideoClip\\("
---

<objective>
Implement video clip generation using Veo 3.1 with first/last frame control and long-running operation polling with exponential backoff, handling RAI filtering gracefully and enabling crash recovery through operation ID persistence.

Purpose: Transforms keyframe pairs into smooth video clips with motion interpolation, implementing the most expensive pipeline step with robust error handling and resume capability.

Output: Video generator with async polling, RAI filter handling, timeout detection, and idempotent operation tracking.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-generation-pipeline/02-RESEARCH.md
@.planning/phases/02-generation-pipeline/02-01-SUMMARY.md
@.planning/phases/02-generation-pipeline/02-02-SUMMARY.md
@docs/spec.md
@vidpipe/db/models.py
@vidpipe/config.py
@vidpipe/services/file_manager.py
@vidpipe/services/vertex_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Veo video generation with polling and error handling</name>
  <files>vidpipe/pipeline/video_gen.py</files>
  <action>
Create async video generator implementing VGEN-01 through VGEN-06 requirements.

Function signature: `async def generate_videos(session: AsyncSession, project: Project) -> None`

Implementation (following research Pattern 4 - Long-running operation polling):

1. Imports:
   - from google.genai import types
   - from vidpipe.services.vertex_client import get_vertex_client
   - from vidpipe.services.file_manager import FileManager
   - from vidpipe.db.models import Scene, Keyframe, VideoClip
   - from vidpipe.config import settings
   - from sqlalchemy import select
   - import asyncio
   - from pathlib import Path

2. Get client and file manager: `client = get_vertex_client()`, `file_mgr = FileManager()`

3. Query scenes with keyframes:
   ```python
   result = await session.execute(
       select(Scene)
       .where(Scene.project_id == project.id)
       .where(Scene.status == "keyframes_done")
       .order_by(Scene.scene_index)
   )
   scenes = result.scalars().all()
   ```

4. For each scene, call `await _generate_video_for_scene(session, scene, file_mgr, client, project)`

5. Update project status: project.status = "stitching"
6. Commit

Helper function (private module function):

`async def _generate_video_for_scene(session: AsyncSession, scene: Scene, file_mgr: FileManager, client, project: Project) -> None:`

a. Load keyframes from database:
   ```python
   result = await session.execute(
       select(Keyframe)
       .where(Keyframe.scene_id == scene.id)
       .order_by(Keyframe.position)
   )
   keyframes = result.scalars().all()
   start_kf = next(k for k in keyframes if k.position == "start")
   end_kf = next(k for k in keyframes if k.position == "end")
   ```

b. Load image bytes from files:
   ```python
   start_frame_bytes = Path(start_kf.file_path).read_bytes()
   end_frame_bytes = Path(end_kf.file_path).read_bytes()
   ```

c. Check if VideoClip already exists (idempotent resume per VGEN-03):
   ```python
   result = await session.execute(select(VideoClip).where(VideoClip.scene_id == scene.id))
   clip = result.scalar_one_or_none()
   ```

d. If clip is None, submit new Veo job:
   ```python
   operation = await client.aio.models.generate_videos(
       model=settings.models.video_gen,  # "veo-3.1-generate-001"
       prompt=scene.video_motion_prompt,
       image=types.Image(image_bytes=start_frame_bytes, mime_type="image/png"),
       config=types.GenerateVideosConfig(
           aspect_ratio=project.aspect_ratio,
           duration_seconds=project.target_clip_duration,
           last_frame=types.Image(image_bytes=end_frame_bytes, mime_type="image/png")
       )
   )

   # CRITICAL: Persist operation ID BEFORE polling (VGEN-03)
   clip = VideoClip(
       scene_id=scene.id,
       operation_name=operation.name,
       status="polling",
       poll_count=0
   )
   session.add(clip)
   await session.commit()
   ```

e. Poll operation with backoff (VGEN-02):
   ```python
   poll_interval = settings.pipeline.video_poll_interval  # default 15s
   max_polls = settings.pipeline.video_poll_max  # default 40 (~10 min)

   for poll_attempt in range(clip.poll_count, max_polls):
       operation = await client.aio.operations.get(clip.operation_name)
       clip.poll_count = poll_attempt + 1

       if operation.done:
           if operation.response:
               # Check for RAI filtering (VGEN-04)
               if hasattr(operation.response, 'raiMediaFilteredCount') and operation.response.raiMediaFilteredCount > 0:
                   clip.status = "rai_filtered"
                   clip.error_message = "Content filtered by responsible AI"
                   scene.status = "rai_filtered"
                   await session.commit()
                   return  # Continue with other scenes

               # Success: download video
               video = operation.response.generated_videos[0]
               video_bytes = video.video_bytes if hasattr(video, 'video_bytes') else await _download_from_gcs(video.gcs_uri)

               # Save video clip (VGEN-06)
               file_path = file_mgr.save_clip(project.id, scene.scene_index, video_bytes)
               clip.local_path = str(file_path)
               clip.status = "complete"
               clip.duration_seconds = project.target_clip_duration
               scene.status = "video_done"
               await session.commit()
               return

           else:
               # Operation failed
               clip.status = "failed"
               clip.error_message = str(operation.error) if hasattr(operation, 'error') else "Unknown error"
               scene.status = "failed"
               await session.commit()
               return

       # Not done yet, commit poll progress and sleep
       await session.commit()
       await asyncio.sleep(poll_interval)

   # Timeout (VGEN-05)
   clip.status = "timed_out"
   clip.error_message = f"Operation did not complete after {max_polls * poll_interval} seconds"
   scene.status = "timed_out"
   await session.commit()
   ```

Optional helper if GCS is used:
`async def _download_from_gcs(gcs_uri: str) -> bytes:` - use httpx to download if needed

Per research Pattern 4 (polling), Code Example 3 (Veo API), Pitfall 3 (RAI filtering), Pitfall 5 (SQLite locks - commit frequently).

CRITICAL: Use `await asyncio.sleep()` NOT `time.sleep()` to avoid blocking event loop (Pitfall 8).

Do NOT fail entire pipeline if one clip is RAI-filtered â€” mark it and continue.
  </action>
  <verify>
Unit test or manual test:
```python
from vidpipe.pipeline.video_gen import generate_videos
from vidpipe.db import async_session
from vidpipe.db.models import Project, VideoClip
from sqlalchemy import select
import asyncio

async def test():
    async with async_session() as session:
        # Assume project with keyframes exists from Plan 02-02
        result = await session.execute(select(Project).limit(1))
        project = result.scalar_one()
        project.status = "generating_video"
        await session.commit()

        await generate_videos(session, project)

        # Verify clips created
        result = await session.execute(select(VideoClip))
        clips = result.scalars().all()
        print(f"Clips created: {len(clips)}")
        print(f"Statuses: {[c.status for c in clips]}")
        print(f"Project status: {project.status}")

asyncio.run(test())
```

Should create VideoClip records with status in ["complete", "rai_filtered", "timed_out"], files saved to tmp/{project_id}/clips/, project status = "stitching".
  </verify>
  <done>
vidpipe/pipeline/video_gen.py exists, exports generate_videos(), submits Veo jobs with first/last frame, persists operation IDs before polling, polls with configurable interval, handles RAI filtering gracefully, marks timeouts, saves MP4 files, creates/updates VideoClip records.
  </done>
</task>

</tasks>

<verification>
End-to-end test:
1. Create project with 3 scenes and keyframes
2. Run generate_videos()
3. Verify: VideoClip records created for each scene
4. Verify: Clips with status="complete" have local_path populated and files exist
5. Verify: RAI-filtered clips have status="rai_filtered" and error_message set
6. Verify: Timed-out clips have status="timed_out" and error_message set
7. Verify: Project status = "stitching"
8. Verify: Scene statuses updated to "video_done", "rai_filtered", or "timed_out"
9. Verify: Poll counts persisted in database
</verification>

<success_criteria>
- [x] Veo video generation uses first-frame + last-frame interpolation (VGEN-01)
- [x] Long-running operations polled with configurable interval and timeout (VGEN-02)
- [x] Operation ID persisted to database before polling begins (VGEN-03)
- [x] RAI-filtered clips marked as rai_filtered and pipeline continues (VGEN-04)
- [x] Timed-out operations marked as timed_out after max polls (VGEN-05)
- [x] Video clips saved as MP4 to tmp/{project_id}/clips/ (VGEN-06)
- [x] VideoClip records track operation_name, status, poll_count, error_message
- [x] Async sleep used in polling loop (not blocking time.sleep)
- [x] Idempotent resume: existing VideoClip records are resumed, not recreated
- [x] Project status updated to "stitching" after all scenes processed
</success_criteria>

<output>
After completion, create `.planning/phases/02-generation-pipeline/02-03-SUMMARY.md`
</output>
