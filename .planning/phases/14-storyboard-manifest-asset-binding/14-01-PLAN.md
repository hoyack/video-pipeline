---
phase: 14-storyboard-manifest-asset-binding
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/vidpipe/pipeline/storyboard.py
  - backend/vidpipe/services/manifest_service.py
  - backend/vidpipe/services/prompt_rewriter.py
  - backend/vidpipe/pipeline/keyframes.py
autonomous: true
requirements:
  - SBIND-01
  - SBIND-02
  - SBIND-03
  - SBIND-04

must_haves:
  truths:
    - "Storyboard LLM prompt mandates using existing CHARACTER tags and forbids creating new CHARACTER tags when matching assets exist in the registry"
    - "Post-storyboard deterministic remapping catches LLM-invented CHARACTER tags and maps them to existing manifest CHARACTER assets before persisting scene manifests"
    - "Prompt rewriter marks ALL manifest CHARACTER assets as MUST SELECT when placed_tags from scene manifest don't resolve to any real assets"
    - "Keyframe enforcement falls back to all manifest CHARACTER assets with reference images when placed_char_tags resolves empty but project has a manifest"
    - "Face verification retry loop fires whenever manifest has CHARACTER assets, regardless of scene manifest tag accuracy"
    - "Projects without manifests are unaffected — original code paths remain unchanged"
  artifacts:
    - path: "backend/vidpipe/pipeline/storyboard.py"
      provides: "Hardened ENHANCED_STORYBOARD_PROMPT + _remap_unrecognized_tags() function"
      contains: "MUST use registered asset tags"
    - path: "backend/vidpipe/services/manifest_service.py"
      provides: "Hardened format_asset_registry() footer"
      contains: "MUST use existing CHARACTER tags"
    - path: "backend/vidpipe/services/prompt_rewriter.py"
      provides: "Fallback MUST SELECT logic in _list_available_references()"
      contains: "if not placed_assets"
    - path: "backend/vidpipe/pipeline/keyframes.py"
      provides: "Fallback to all manifest CHARACTER assets when placed_char_tags is empty"
      contains: "if not placed_char_tags and project.manifest_id"
  key_links:
    - from: "backend/vidpipe/pipeline/storyboard.py"
      to: "_remap_unrecognized_tags"
      via: "called after generate_with_retry() before persisting scene manifests"
      pattern: "_remap_unrecognized_tags"
    - from: "backend/vidpipe/services/prompt_rewriter.py"
      to: "placed_assets fallback"
      via: "if not placed_assets, use all CHARACTER assets with reference_image_url"
      pattern: "if not placed_assets"
    - from: "backend/vidpipe/pipeline/keyframes.py"
      to: "placed_char_tags fallback"
      via: "if empty and project.manifest_id, use all manifest CHARACTER assets"
      pattern: "if not placed_char_tags and project\\.manifest_id"
---

<objective>
Defense-in-depth fix for storyboard LLM creating new CHARACTER tags instead of using existing manifest assets.

Purpose: When a manifest with CHARACTER assets (e.g. CHAR_01, CHAR_02, CHAR_03) is attached to a project, the storyboard LLM frequently invents new tags (CHAR_04, CHAR_05) instead of referencing existing ones. This breaks the entire downstream reference image pipeline -- keyframes generate without face references, face verification is skipped, and output has zero resemblance to manifest reference images. Four independent safety layers prevent this failure cascade.

Output: Modified storyboard.py, manifest_service.py, prompt_rewriter.py, and keyframes.py with hardened prompts, deterministic tag remapping, and fallback logic at every layer.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/storyboard-spec.md
@backend/vidpipe/pipeline/storyboard.py
@backend/vidpipe/services/manifest_service.py
@backend/vidpipe/services/prompt_rewriter.py
@backend/vidpipe/pipeline/keyframes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Storyboard prompt hardening + post-LLM tag remapping (SBIND-01, SBIND-02)</name>
  <files>
    backend/vidpipe/pipeline/storyboard.py
    backend/vidpipe/services/manifest_service.py
  </files>
  <action>
**SBIND-01 — Prompt hardening (storyboard.py):**

Replace the SCENE MANIFEST INSTRUCTIONS block in ENHANCED_STORYBOARD_PROMPT (lines 101-109) with:

```
SCENE MANIFEST INSTRUCTIONS:
When creating scenes, generate a scene_manifest for each scene:
- You MUST use registered asset tags from the Available Assets list for ALL characters
  and environments that match existing assets. Do NOT create new CHARACTER tags when
  a matching character already exists in the registry.
- Reference assets by their exact [TAG] (e.g., [CHAR_01], [ENV_02])
- Use the asset's reverse_prompt for visual detail — it's already optimized for generation
- Assign roles: subject, background, prop, interaction_target, environment
- Specify spatial positions and actions for each placed asset
- Include composition metadata: shot_type, camera_movement, focal_point
- Add continuity_notes describing visual continuity with previous scenes
- new_asset_declarations: ONLY for genuinely new assets that have NO match in the
  registry (e.g., background extras, props, environments not yet registered).
  NEVER declare a new CHARACTER when the registry already has CHARACTER assets
  that could represent that person.
```

Key changes: line 103 changes from "Reference registered assets by their [TAG]" to "You MUST use registered asset tags..." with explicit prohibition. Line 109 changes from "You MAY declare new_asset_declarations" to explicit restriction to non-CHARACTER types.

**SBIND-01 — Footer hardening (manifest_service.py):**

Replace line 796 in format_asset_registry():
```python
# OLD:
lines.append("Reference assets by [TAG]. You may declare NEW assets not in the registry.")

# NEW:
lines.append("Reference assets by [TAG]. You MUST use existing CHARACTER tags — do NOT")
lines.append("create new CHARACTER tags for people already represented in the registry.")
lines.append("You may declare new ENVIRONMENT or PROP assets not in the registry.")
```

**SBIND-02 — Post-storyboard tag remapping (storyboard.py):**

Add a new module-level function `_remap_unrecognized_tags()` before `generate_storyboard()`:

```python
def _remap_unrecognized_tags(
    scene_manifest_data: dict,
    asset_tags_set: set[str],
    manifest_characters: list[str],
) -> dict:
    """Remap unrecognized CHARACTER tags to existing manifest CHARACTER assets.

    Deterministic backstop for LLM tag invention. Catches cases where the LLM
    creates CHAR_04/CHAR_05 instead of using CHAR_01/CHAR_02/CHAR_03.

    Strategy:
    - Collect placement tags not in asset_tags_set that look like CHARACTER tags
    - Map to existing manifest CHARACTER assets by positional order
    - Replace tags in-place in the placements list
    - Remove remapped entries from new_asset_declarations

    Args:
        scene_manifest_data: Dict from scene_manifest.model_dump()
        asset_tags_set: Set of all valid asset tags from the manifest
        manifest_characters: Sorted list of existing CHARACTER tags (e.g. ["CHAR_01", "CHAR_02"])

    Returns:
        Modified scene_manifest_data dict with remapped tags
    """
    if not manifest_characters:
        return scene_manifest_data

    placements = scene_manifest_data.get("placements", [])
    unrecognized_chars = []
    for p in placements:
        tag = p.get("asset_tag", "")
        if tag not in asset_tags_set and tag.startswith("CHAR_"):
            unrecognized_chars.append(tag)

    if not unrecognized_chars:
        return scene_manifest_data

    # Build remap: positional mapping (first unrecognized -> first manifest char, etc.)
    remap = {}
    for i, unrec_tag in enumerate(unrecognized_chars):
        if i < len(manifest_characters):
            remap[unrec_tag] = manifest_characters[i]
        # If more unrecognized than manifest chars, extras are left unmapped

    # Apply remap to placements
    for p in placements:
        tag = p.get("asset_tag", "")
        if tag in remap:
            logger.info(
                "Tag remap: %s -> %s in scene manifest placement",
                tag, remap[tag]
            )
            p["asset_tag"] = remap[tag]

    # Remove remapped entries from new_asset_declarations
    new_decls = scene_manifest_data.get("new_asset_declarations") or []
    if new_decls and remap:
        remapped_tags = set(remap.keys())
        scene_manifest_data["new_asset_declarations"] = [
            d for d in new_decls
            if d.get("tag") not in remapped_tags and d.get("asset_tag") not in remapped_tags
        ]

    return scene_manifest_data
```

Then in `generate_storyboard()`, after line 263 (`storyboard = await generate_with_retry()`) and inside the `if use_manifests:` block (line 284), add the remapping call BEFORE persisting scene manifests. Specifically, replace the existing post-validation block (lines 284-326) to add the remap step. Before the `for scene_data in storyboard.scenes:` loop that persists scene manifests, collect manifest CHARACTER tags:

```python
    if use_manifests:
        # Collect manifest CHARACTER tags for remapping
        manifest_characters = sorted([
            a.manifest_tag for a in assets
            if a.asset_type == "CHARACTER" and a.manifest_tag
        ])

        for scene_data in storyboard.scenes:
            # SBIND-02: Deterministic remap of unrecognized CHARACTER tags
            remapped_manifest = _remap_unrecognized_tags(
                scene_data.scene_manifest.model_dump(),
                asset_tags_set,
                manifest_characters,
            )

            # Post-validate asset tags (on remapped data)
            for placement in remapped_manifest.get("placements", []):
                tag = placement.get("asset_tag", "")
                if tag not in asset_tags_set:
                    logger.warning(
                        "Project %s scene %d: unrecognized asset tag '%s' "
                        "(not in registry, may be declared as new asset)",
                        project.id, scene_data.scene_index, tag
                    )

            # Persist scene manifest (using remapped data)
            scene_manifest = SceneManifestModel(
                project_id=project.id,
                scene_index=scene_data.scene_index,
                manifest_json=remapped_manifest,
                composition_shot_type=scene_data.scene_manifest.composition.shot_type,
                composition_camera_movement=scene_data.scene_manifest.composition.camera_movement,
                asset_tags=[p.get("asset_tag", "") for p in remapped_manifest.get("placements", [])],
                new_asset_count=len(remapped_manifest.get("new_asset_declarations") or []),
            )
            session.add(scene_manifest)
            # ... audio manifest persistence unchanged ...
```

The audio manifest block (lines 308-321) stays identical. Only the scene manifest path changes to use `remapped_manifest` instead of `scene_data.scene_manifest.model_dump()`.

Do NOT modify the `STORYBOARD_SYSTEM_PROMPT` (non-manifest path) or the audio manifest persistence -- only the ENHANCED prompt and scene manifest persistence are affected. The non-manifest code path must remain untouched for backward compatibility.
  </action>
  <verify>
    1. `grep -n "MUST use registered asset tags" backend/vidpipe/pipeline/storyboard.py` — confirms hardened prompt text present
    2. `grep -n "MUST use existing CHARACTER tags" backend/vidpipe/services/manifest_service.py` — confirms hardened footer
    3. `grep -n "_remap_unrecognized_tags" backend/vidpipe/pipeline/storyboard.py` — confirms function defined and called
    4. `grep -n "You MAY declare" backend/vidpipe/pipeline/storyboard.py` — should return NO results (old permissive text removed)
    5. `python -c "import backend.vidpipe.pipeline.storyboard"` — confirms no syntax errors
    6. `python -c "import backend.vidpipe.services.manifest_service"` — confirms no syntax errors
  </verify>
  <done>
    - ENHANCED_STORYBOARD_PROMPT mandates existing CHARACTER tags and restricts new_asset_declarations to non-CHARACTER types
    - format_asset_registry() footer reinforces CHARACTER tag mandate
    - _remap_unrecognized_tags() function exists and is called after LLM generation, before scene manifest persistence
    - Remapping logs every tag replacement at INFO level
    - Non-manifest code path is completely unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Prompt rewriter + keyframe enforcement fallbacks (SBIND-03, SBIND-04)</name>
  <files>
    backend/vidpipe/services/prompt_rewriter.py
    backend/vidpipe/pipeline/keyframes.py
  </files>
  <action>
**SBIND-03 — Prompt rewriter fallback (prompt_rewriter.py):**

In `_list_available_references()`, after line 485-486 where placed_assets and unplaced_assets are computed:

```python
    placed_assets = [a for a in with_images if a.manifest_tag in placed_tags]
    unplaced_assets = [a for a in with_images if a.manifest_tag not in placed_tags]
```

Add a fallback block immediately after:

```python
    # SBIND-03 FALLBACK: if no placed assets resolved but manifest has CHARACTER
    # assets with reference images, mark ALL characters as MUST SELECT.
    # This catches cases where storyboard LLM invented tags (CHAR_04) that don't
    # exist in the registry, so placed_tags produced zero matches.
    if not placed_assets:
        char_assets_with_images = [
            a for a in with_images
            if a.asset_type == "CHARACTER" and a.reference_image_url
        ]
        if char_assets_with_images:
            logger.info(
                "Prompt rewriter fallback: no placed assets resolved from tags %s, "
                "marking all %d CHARACTER assets as MUST SELECT",
                placed_tags, len(char_assets_with_images)
            )
            placed_assets = char_assets_with_images
            unplaced_assets = [a for a in with_images if a not in placed_assets]
```

This requires adding `import logging` and `logger = logging.getLogger(__name__)` at the top of prompt_rewriter.py if not already present. Check existing imports first -- the file likely already has logging since it uses an LLM adapter.

**SBIND-04 — Keyframe enforcement fallback (keyframes.py):**

In keyframes.py, after the `placed_char_tags` set comprehension (lines 541-548), add a fallback:

```python
                    placed_char_tags = {
                        p["asset_tag"]
                        for p in scene_manifest_row.manifest_json.get("placements", [])
                        if "asset_tag" in p
                        and asset_map.get(p["asset_tag"])
                        and asset_map[p["asset_tag"]].asset_type == "CHARACTER"
                        and asset_map[p["asset_tag"]].reference_image_url
                    }

                    # SBIND-04 FALLBACK: if scene has placements but none resolved to
                    # manifest characters, use ALL manifest CHARACTER assets with
                    # reference images. This ensures reference images always reach the
                    # image adapter and face verification is never silently skipped.
                    if not placed_char_tags and project.manifest_id:
                        placed_char_tags = {
                            a.manifest_tag
                            for a in all_assets
                            if a.asset_type == "CHARACTER" and a.reference_image_url
                        }
                        if placed_char_tags:
                            logger.warning(
                                "Scene %d: no placed chars resolved from scene manifest, "
                                "falling back to all manifest CHARACTER assets: %s",
                                scene.scene_index, placed_char_tags
                            )
```

This goes between the existing `placed_char_tags` computation and the `current_tags` / `missing_chars` enforcement block (line 549). The rest of the enforcement and face verification code remains unchanged -- `placed_char_assets` on line 560-564 will now correctly populate from the fallback tags since they ARE valid asset_map keys.

Do NOT modify any other logic in keyframes.py. The fallback only activates when placed_char_tags is empty AND project has a manifest -- projects without manifests are unaffected.
  </action>
  <verify>
    1. `grep -n "SBIND-03 FALLBACK" backend/vidpipe/services/prompt_rewriter.py` — confirms fallback block present
    2. `grep -n "SBIND-04 FALLBACK" backend/vidpipe/pipeline/keyframes.py` — confirms fallback block present
    3. `grep -n "if not placed_assets" backend/vidpipe/services/prompt_rewriter.py` — confirms fallback condition
    4. `grep -n "if not placed_char_tags and project.manifest_id" backend/vidpipe/pipeline/keyframes.py` — confirms fallback condition
    5. `python -c "import backend.vidpipe.services.prompt_rewriter"` — confirms no syntax errors
    6. `python -c "import backend.vidpipe.pipeline.keyframes"` — confirms no syntax errors
  </verify>
  <done>
    - Prompt rewriter marks ALL manifest CHARACTER assets as MUST SELECT when placed_tags don't resolve to any real assets
    - Keyframe enforcement falls back to all manifest CHARACTER assets with reference images when placed_char_tags is empty and project has a manifest
    - Both fallbacks log at INFO/WARNING level for debugging
    - Face verification retry loop now fires whenever manifest has CHARACTER assets, regardless of scene manifest tag accuracy (because placed_char_assets is populated from the fallback placed_char_tags)
    - Projects without manifests are completely unaffected (fallback conditions include manifest_id check)
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full defense-in-depth chain:

1. **Layer 1 (SBIND-01):** `grep "MUST use registered asset tags" backend/vidpipe/pipeline/storyboard.py` returns match
2. **Layer 1 (SBIND-01):** `grep "MUST use existing CHARACTER tags" backend/vidpipe/services/manifest_service.py` returns match
3. **Layer 2 (SBIND-02):** `grep "_remap_unrecognized_tags" backend/vidpipe/pipeline/storyboard.py` returns function def + call site
4. **Layer 3 (SBIND-03):** `grep "SBIND-03 FALLBACK" backend/vidpipe/services/prompt_rewriter.py` returns match
5. **Layer 4 (SBIND-04):** `grep "SBIND-04 FALLBACK" backend/vidpipe/pipeline/keyframes.py` returns match
6. **No regression:** `grep "STORYBOARD_SYSTEM_PROMPT" backend/vidpipe/pipeline/storyboard.py` — non-manifest prompt unchanged
7. **Import check:** `cd backend && python -c "from vidpipe.pipeline.storyboard import generate_storyboard; from vidpipe.services.prompt_rewriter import PromptRewriterService; from vidpipe.pipeline.keyframes import generate_keyframes; print('All imports OK')"` — no import errors
</verification>

<success_criteria>
- All 4 files modified with defense-in-depth fixes
- ENHANCED_STORYBOARD_PROMPT forbids new CHARACTER tag creation when matching assets exist
- format_asset_registry() footer reinforces CHARACTER tag mandate
- _remap_unrecognized_tags() catches and fixes LLM-invented CHARACTER tags deterministically
- Prompt rewriter falls back to all CHARACTER assets as MUST SELECT when placed tags don't resolve
- Keyframe enforcement falls back to all CHARACTER assets when placed_char_tags is empty
- Face verification fires for all manifest CHARACTER assets regardless of tag accuracy
- Non-manifest projects follow original code paths with zero changes
- All 4 requirement IDs (SBIND-01 through SBIND-04) are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/14-storyboard-manifest-asset-binding/14-01-SUMMARY.md`
</output>
