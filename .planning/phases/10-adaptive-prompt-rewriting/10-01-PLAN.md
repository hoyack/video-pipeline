---
phase: 10-adaptive-prompt-rewriting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/vidpipe/db/models.py
  - backend/vidpipe/schemas/prompt_rewrite.py
  - backend/vidpipe/services/prompt_rewriter.py
  - backend/migrate_phase10.sql
autonomous: true

must_haves:
  truths:
    - "PromptRewriterService produces structured keyframe prompt output from scene + manifest + asset + continuity inputs"
    - "PromptRewriterService produces structured video prompt output from scene + manifest + asset + continuity + audio inputs"
    - "Rewriter output includes exactly 3 selected_reference_tags with reasoning"
    - "Continuity patch correctly handles scene 0 (no previous scene) and scene N (uses N-1 cv_analysis_json)"
    - "Rewriter gracefully falls back on Gemini failure after 3 retries"
    - "SceneManifest model has rewritten_keyframe_prompt and rewritten_video_prompt columns"
  artifacts:
    - path: "backend/vidpipe/schemas/prompt_rewrite.py"
      provides: "RewrittenKeyframePromptOutput and RewrittenVideoPromptOutput pydantic schemas"
      exports: ["RewrittenKeyframePromptOutput", "RewrittenVideoPromptOutput"]
    - path: "backend/vidpipe/services/prompt_rewriter.py"
      provides: "PromptRewriterService with rewrite_keyframe_prompt and rewrite_video_prompt methods"
      exports: ["PromptRewriterService"]
    - path: "backend/vidpipe/db/models.py"
      provides: "SceneManifest with 2 new nullable Text columns"
      contains: "rewritten_keyframe_prompt"
    - path: "backend/migrate_phase10.sql"
      provides: "SQL migration for existing databases"
      contains: "ALTER TABLE scene_manifests"
  key_links:
    - from: "backend/vidpipe/services/prompt_rewriter.py"
      to: "backend/vidpipe/schemas/prompt_rewrite.py"
      via: "import RewrittenKeyframePromptOutput, RewrittenVideoPromptOutput"
      pattern: "from vidpipe\\.schemas\\.prompt_rewrite import"
    - from: "backend/vidpipe/services/prompt_rewriter.py"
      to: "vidpipe.services.vertex_client"
      via: "get_vertex_client() for Gemini calls"
      pattern: "get_vertex_client"
    - from: "backend/vidpipe/services/prompt_rewriter.py"
      to: "vidpipe.services.manifest_service"
      via: "format_placed_assets_for_rewriter uses Asset model"
      pattern: "Asset"
---

<objective>
Create the PromptRewriterService, pydantic output schemas, and SceneManifest schema extension for adaptive prompt rewriting.

Purpose: Establish the rewriter service that assembles five structured inputs (original prompt, manifest metadata, asset reverse_prompts, continuity patches, audio direction) and calls Gemini 2.5 Flash to produce cinematography-formula prompts with LLM-reasoned reference selection. This is the core intelligence layer that Plan 02 will hook into the pipeline.

Output: New service file, new schema file, updated SceneManifest model with 2 new columns, SQL migration.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-adaptive-prompt-rewriting/10-RESEARCH.md
@backend/vidpipe/db/models.py
@backend/vidpipe/services/manifest_service.py
@backend/vidpipe/schemas/storyboard_enhanced.py
@backend/vidpipe/pipeline/storyboard.py
@backend/vidpipe/services/vertex_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pydantic schemas, SceneManifest columns, and SQL migration</name>
  <files>
    backend/vidpipe/schemas/prompt_rewrite.py
    backend/vidpipe/db/models.py
    backend/migrate_phase10.sql
  </files>
  <action>
Create `backend/vidpipe/schemas/prompt_rewrite.py` with two pydantic BaseModel schemas:

1. `RewrittenKeyframePromptOutput`:
   - `rewritten_prompt: str` — Field description: "Final keyframe generation prompt, under 400 words, following [Cinematography]+[Subject]+[Action]+[Context]+[Style] formula"
   - `selected_reference_tags: list[str]` — Field description: "Exactly 3 manifest_tags of assets selected as references, ordered by priority"
   - `reference_reasoning: str` — Field description: "One sentence explaining why these 3 references were chosen"
   - `continuity_applied: Optional[str] = None` — Field description: "Summary of continuity corrections applied (None if scene 0)"

2. `RewrittenVideoPromptOutput`:
   - `rewritten_prompt: str` — Field description: "Final video generation prompt, under 500 words. Motion-focused. Audio direction embedded: dialogue in quotes, SFX:, Ambient:, Music:"
   - `selected_reference_tags: list[str]` — same as above
   - `reference_reasoning: str` — same as above
   - `continuity_applied: Optional[str] = None` — same as above

Add 2 new nullable Text columns to `SceneManifest` in `models.py`:
- `rewritten_keyframe_prompt: Mapped[Optional[str]] = mapped_column(Text, nullable=True)`
- `rewritten_video_prompt: Mapped[Optional[str]] = mapped_column(Text, nullable=True)`

Place them after `continuity_score` and before `created_at`, with a `# Phase 10: Adaptive Prompt Rewriting` comment.

Create `backend/migrate_phase10.sql`:
```sql
-- Phase 10: Adaptive Prompt Rewriting — add rewritten prompt columns
ALTER TABLE scene_manifests ADD COLUMN rewritten_keyframe_prompt TEXT;
ALTER TABLE scene_manifests ADD COLUMN rewritten_video_prompt TEXT;
```
  </action>
  <verify>
Run `python -c "from vidpipe.schemas.prompt_rewrite import RewrittenKeyframePromptOutput, RewrittenVideoPromptOutput; print('OK')"` from backend/ directory.
Run `python -c "from vidpipe.db.models import SceneManifest; assert hasattr(SceneManifest, 'rewritten_keyframe_prompt'); assert hasattr(SceneManifest, 'rewritten_video_prompt'); print('OK')"` from backend/ directory.
Verify migrate_phase10.sql exists and contains both ALTER TABLE statements.
  </verify>
  <done>
RewrittenKeyframePromptOutput and RewrittenVideoPromptOutput importable. SceneManifest has rewritten_keyframe_prompt and rewritten_video_prompt columns. Migration SQL exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: PromptRewriterService with context assembly and Gemini calls</name>
  <files>backend/vidpipe/services/prompt_rewriter.py</files>
  <action>
Create `backend/vidpipe/services/prompt_rewriter.py` implementing the full rewriter service. Follow patterns from `storyboard.py` (Gemini structured output) and `reverse_prompt_service.py` (retry + semaphore).

**Class: `PromptRewriterService`**

Properties and init:
- `_client = None` (lazy init)
- `_semaphore = asyncio.Semaphore(5)` — class-level, matches Phase 5 pattern
- `client` property returns `get_vertex_client()` lazily

**Method: `rewrite_keyframe_prompt(self, scene, scene_manifest_json, placed_assets, previous_cv_analysis, all_assets) -> RewrittenKeyframePromptOutput`**
- Wraps in `self._semaphore`
- Calls `_build_keyframe_system_prompt()` (static string)
- Calls `_assemble_keyframe_context(scene, scene_manifest_json, placed_assets, previous_cv_analysis, all_assets)` which assembles:
  - ORIGINAL PROMPT section: `scene.start_frame_prompt`
  - SCENE COMPOSITION section: shot_type, camera_movement, focal_point from `scene_manifest_json["composition"]`
  - PLACED ASSETS section: call `_format_placed_assets(scene_manifest_json, all_assets)` (inline helper, see below)
  - CONTINUITY PATCH section: call `_build_continuity_patch(previous_cv_analysis, scene.scene_index)`
  - AVAILABLE REFERENCES section: list all assets with manifest_tag and whether they have reference_image_url (so LLM can select from those that actually have images)
- Calls `_call_rewriter(system_prompt, user_context, RewrittenKeyframePromptOutput)` which does the Gemini call

**Method: `rewrite_video_prompt(self, scene, scene_manifest_json, audio_manifest_json, placed_assets, previous_cv_analysis, all_assets) -> RewrittenVideoPromptOutput`**
- Same pattern as keyframe but with:
  - ORIGINAL PROMPT section: `scene.video_motion_prompt`
  - AUDIO DIRECTION section: call `_format_audio_direction(audio_manifest_json)` — formats dialogue, SFX, ambient, music
  - Same SCENE COMPOSITION, PLACED ASSETS, CONTINUITY PATCH, AVAILABLE REFERENCES sections

**Method: `_call_rewriter(self, system_prompt, user_context, schema) -> schema`**
- Uses tenacity: `@retry(stop=stop_after_attempt(3), retry=retry_if_exception_type(Exception))`
- Calls `self.client.aio.models.generate_content()` with:
  - `model="gemini-2.5-flash"` (use settings.models.text if available, else hardcode)
  - `contents=[f"{system_prompt}\n\n{user_context}"]`
  - `config=types.GenerateContentConfig(response_mime_type="application/json", response_schema=schema, temperature=0.4)`
- Parses with `schema.model_validate_json(response.text)`
- On failure after retries, raises the exception (caller wraps in try/except for graceful fallback)

**System prompts** (as module-level constants):

`KEYFRAME_REWRITER_SYSTEM_PROMPT` — Exact text from research Pattern 3, instructs:
- Follow [Cinematography]+[Subject]+[Action]+[Context]+[Style] formula
- Use reverse_prompt details verbatim for subjects
- Include spatial positions from manifest placements
- Apply continuity corrections from previous scene CV analysis
- Keep under 400 words
- Select exactly 3 reference tags with reasoning
- Do NOT reference audio (keyframes are static images)

`VIDEO_REWRITER_SYSTEM_PROMPT` — Exact text from research Pattern 3, instructs:
- Follow [Cinematography]+[Subject]+[Action]+[Context]+[Style]+[Audio] formula
- Describe MOTION only (reference images provide visual context)
- Camera movement from manifest
- Embed audio direction (Dialogue, SFX, Ambient, Music notation)
- Apply continuity corrections
- Keep under 500 words
- Select exactly 3 reference tags with reasoning

**Helper functions** (module-level or static methods):

`_format_placed_assets(scene_manifest_json, all_assets)` — Adapted from research Pattern (format_placed_assets_for_rewriter). Build asset_map by manifest_tag. For each placement in manifest_json["placements"]: output tag, name, role, position, action, expression, wardrobe_note, reverse_prompt truncated to 200 chars, visual_description (only if quality >= 7.0) truncated to 150 chars.

`_build_continuity_patch(previous_cv_analysis, scene_index)` — From research Pattern 4. If scene_index == 0 or previous_cv_analysis is None: return "CONTINUITY: First scene — no previous scene continuity needed." Otherwise extract semantic_analysis.continuity_issues, semantic_analysis.overall_scene_description, and continuity_score. Format as structured block.

`_format_audio_direction(audio_manifest_json)` — From research code example. Format dialogue_lines (speaker says "line" with delivery at timing), sfx (effect at timing, volume), ambient (base_layer, environmental), music (style, mood, tempo, transition). Return "AUDIO: No audio direction specified." if None.

`_list_available_references(all_assets)` — Lists all assets that have reference_image_url (not None), with their manifest_tag, name, asset_type, is_face_crop status, quality_score. This gives the LLM the full menu to select from. Only assets WITH images can be references.

**CRITICAL implementation notes:**
- Import types from google.genai (not google.generativeai — this project uses Vertex AI mode)
- Use `get_vertex_client()` from `vidpipe.services.vertex_client` (singleton pattern)
- The `scene` parameter type is `Scene` from `vidpipe.db.models`
- The `placed_assets` and `all_assets` parameters are `list[Asset]` from `vidpipe.db.models`
- Follow the exact import patterns from storyboard.py
  </action>
  <verify>
Run `python -c "from vidpipe.services.prompt_rewriter import PromptRewriterService; print('OK')"` from backend/ directory.
Run `python -c "from vidpipe.services.prompt_rewriter import PromptRewriterService; svc = PromptRewriterService(); print(type(svc))"` from backend/ directory — should instantiate without error (no Gemini call yet).
Verify the module has both system prompt constants by checking: `python -c "from vidpipe.services import prompt_rewriter; assert hasattr(prompt_rewriter, 'KEYFRAME_REWRITER_SYSTEM_PROMPT'); assert hasattr(prompt_rewriter, 'VIDEO_REWRITER_SYSTEM_PROMPT'); print('OK')"`
  </verify>
  <done>
PromptRewriterService importable with rewrite_keyframe_prompt and rewrite_video_prompt methods. Context assembly functions correctly format placed assets with 200-char reverse_prompt truncation, continuity patches with scene-0 guard, audio direction with all 4 blocks, and available reference listing. Gemini call uses structured output with response_schema and temperature 0.4.
  </done>
</task>

</tasks>

<verification>
1. All new imports resolve: `python -c "from vidpipe.schemas.prompt_rewrite import RewrittenKeyframePromptOutput, RewrittenVideoPromptOutput; from vidpipe.services.prompt_rewriter import PromptRewriterService; print('All imports OK')"`
2. SceneManifest model updated: `python -c "from vidpipe.db.models import SceneManifest; cols = [c.name for c in SceneManifest.__table__.columns]; assert 'rewritten_keyframe_prompt' in cols; assert 'rewritten_video_prompt' in cols; print('Columns OK')"`
3. Migration file exists: `cat backend/migrate_phase10.sql`
4. No circular imports: `python -c "import vidpipe.services.prompt_rewriter; import vidpipe.pipeline.keyframes; import vidpipe.pipeline.video_gen; print('No circular imports')"`
</verification>

<success_criteria>
- PromptRewriterService instantiates and has rewrite_keyframe_prompt + rewrite_video_prompt methods
- Both methods accept the documented parameters (scene, manifest_json, assets, cv_analysis, etc.)
- Schema models have all 4 fields with proper Field descriptions
- SceneManifest has 2 new nullable Text columns
- SQL migration file covers both columns
- System prompts follow cinematography formula from research
- Context assembly handles all 5 inputs: original prompt, composition, placed assets, continuity, audio (video only)
- Continuity patch guards scene_index == 0
- Asset formatting truncates reverse_prompt to 200 chars, visual_description to 150 chars (quality >= 7.0 only)
</success_criteria>

<output>
After completion, create `.planning/phases/10-adaptive-prompt-rewriting/10-01-SUMMARY.md`
</output>
