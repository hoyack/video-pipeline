---
phase: 08-veo-reference-passthrough-and-clean-sheets
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/vidpipe/db/models.py
  - backend/vidpipe/db/__init__.py
  - backend/vidpipe/services/reference_selection.py
autonomous: true

must_haves:
  truths:
    - "AssetCleanReference model exists and can store clean sheet records with tier, quality, and face similarity"
    - "SceneManifest has a selected_reference_tags column to record which 3 assets were picked per scene"
    - "Reference selection logic picks up to 3 assets per scene based on role priority and scene composition type"
    - "Selection adapts to scene type: close-ups prioritize face crops, establishing shots prioritize environments"
  artifacts:
    - path: "backend/vidpipe/db/models.py"
      provides: "AssetCleanReference ORM model and SceneManifest.selected_reference_tags column"
      contains: "class AssetCleanReference"
    - path: "backend/vidpipe/services/reference_selection.py"
      provides: "select_references_for_scene function with scene-type-aware selection logic"
      exports: ["select_references_for_scene", "get_primary_clean_reference"]
  key_links:
    - from: "backend/vidpipe/services/reference_selection.py"
      to: "backend/vidpipe/db/models.py"
      via: "imports Asset, AssetCleanReference, SceneManifest"
      pattern: "from vidpipe.db.models import"
    - from: "backend/vidpipe/services/reference_selection.py"
      to: "backend/vidpipe/schemas/storyboard_enhanced.py"
      via: "uses SceneManifestSchema for placement/composition data"
      pattern: "SceneManifestSchema|AssetPlacement|SceneComposition"
---

<objective>
Add the AssetCleanReference database model, extend SceneManifest with selected_reference_tags, and implement the 3-reference selection service that picks optimal reference images per scene based on asset roles and scene composition type.

Purpose: Provides the data layer and selection logic that Plan 02 (video gen pipeline) and Plan 03 (frontend display) both depend on.
Output: New ORM model, updated SceneManifest, and reference selection service module.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-veo-reference-passthrough-and-clean-sheets/08-RESEARCH.md
@backend/vidpipe/db/models.py
@backend/vidpipe/schemas/storyboard_enhanced.py
@backend/vidpipe/services/manifest_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AssetCleanReference model and SceneManifest.selected_reference_tags column</name>
  <files>backend/vidpipe/db/models.py, backend/vidpipe/db/__init__.py</files>
  <action>
Add new AssetCleanReference ORM model to models.py after the Asset class. Fields:

```python
class AssetCleanReference(Base):
    """Clean reference image generated for an asset at a specific quality tier.

    Stores preprocessed reference images separately from originals.
    Never overwrites Asset.reference_image_url.

    Spec reference: Phase 8 - Clean Sheets
    """
    __tablename__ = "asset_clean_references"

    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)
    asset_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("assets.id"), index=True)
    tier: Mapped[str] = mapped_column(String(20))  # 'tier2_rembg', 'tier3_gemini'
    clean_image_url: Mapped[str] = mapped_column(String(500))
    generation_prompt: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    face_similarity_score: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    quality_score: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    is_primary: Mapped[bool] = mapped_column(Boolean, default=False)
    generation_cost: Mapped[float] = mapped_column(Float, default=0.0)
    created_at: Mapped[datetime] = mapped_column(server_default=func.now())
```

Add `selected_reference_tags` column to the existing SceneManifest class:

```python
selected_reference_tags: Mapped[Optional[list]] = mapped_column(JSON, nullable=True)
```

This stores the list of manifest_tag strings (e.g. ["CHAR_01", "CHAR_02", "ENV_01"]) selected for Veo reference passthrough.

Import AssetCleanReference in `backend/vidpipe/db/__init__.py` alongside the existing model imports to register it with Base.metadata for auto-creation.
  </action>
  <verify>
Run: `python -c "from vidpipe.db.models import AssetCleanReference, SceneManifest; print('AssetCleanReference:', [c.name for c in AssetCleanReference.__table__.columns]); print('SceneManifest selected_reference_tags:', hasattr(SceneManifest, 'selected_reference_tags'))"`

Expected: AssetCleanReference columns listed (id, asset_id, tier, clean_image_url, generation_prompt, face_similarity_score, quality_score, is_primary, generation_cost, created_at), SceneManifest selected_reference_tags = True.
  </verify>
  <done>AssetCleanReference model exists with all 10 columns. SceneManifest has selected_reference_tags JSON column. Both registered in Base.metadata.</done>
</task>

<task type="auto">
  <name>Task 2: Implement reference selection service with scene-type-aware logic</name>
  <files>backend/vidpipe/services/reference_selection.py</files>
  <action>
Create new file `backend/vidpipe/services/reference_selection.py` with two functions:

**1. `select_references_for_scene(scene_manifest_json: dict, all_assets: list[Asset]) -> list[Asset]`**

This is the core 3-reference selection logic. Takes the scene manifest JSON (from SceneManifest.manifest_json) and all manifest assets, returns up to 3 Asset objects.

Implementation:
- Parse scene_manifest_json into a SceneManifestSchema pydantic model (from vidpipe.schemas.storyboard_enhanced)
- Build asset_map: `{asset.manifest_tag: asset for asset in all_assets}`
- Extract shot_type from composition: `scene_manifest.composition.shot_type`
- Map placements to asset objects, skip any tags not found in asset_map (these are new_asset_declarations from LLM)

Scene-type-aware selection per user's locked decision (from v2-pipe-optimization.md Decision 1):

For "close_up":
  - Prioritize face crops of subject role assets (is_face_crop=True)
  - Then full-body subject assets
  - Then environment assets

For "two_shot":
  - Get up to 2 unique CHARACTER assets from subject/interaction_target roles
  - Fill remaining slot with environment asset

For "establishing":
  - Prioritize ENVIRONMENT type assets
  - Then PROP/VEHICLE type assets
  - Characters last

For "medium_shot", "wide_shot", and any other shot type (default):
  - Standard priority: subject role first, then interaction_target, then background
  - Sort by quality_score descending within each priority group

Special handling for character face crops:
- If CHAR_XX has both face crop (is_face_crop=True, source_asset_id set) and full-body in asset pool:
  - For close_up/two_shot: prefer face crop
  - For wide_shot/establishing: prefer full-body
- Deduplicate by manifest_tag (same character should not occupy 2 slots unless it's different crops for close-up scenes)

Always return at most 3 assets. Return empty list if no placements or no matching assets.

**2. `async get_primary_clean_reference(session: AsyncSession, asset_id: uuid.UUID) -> Optional[AssetCleanReference]`**

Query asset_clean_references table for the given asset_id where is_primary=True. Return the first match or None. This is used by video_gen to check if a clean sheet override exists.

```python
async def get_primary_clean_reference(
    session: AsyncSession,
    asset_id: uuid.UUID,
) -> Optional[AssetCleanReference]:
    from vidpipe.db.models import AssetCleanReference
    result = await session.execute(
        select(AssetCleanReference).where(
            AssetCleanReference.asset_id == asset_id,
            AssetCleanReference.is_primary == True,
        )
    )
    return result.scalar_one_or_none()
```

Add proper module docstring, logging, and type hints. Follow existing service patterns (accept session parameter, use select() queries).
  </action>
  <verify>
Run: `python -c "from vidpipe.services.reference_selection import select_references_for_scene, get_primary_clean_reference; print('Imports OK')"` -- confirms module loads.

Then test selection logic with a mock:
```python
python -c "
from vidpipe.services.reference_selection import select_references_for_scene

# Mock Asset objects
class MockAsset:
    def __init__(self, tag, asset_type, role_hint, quality=5.0, is_face=False):
        self.manifest_tag = tag
        self.asset_type = asset_type
        self.quality_score = quality
        self.is_face_crop = is_face
        self.source_asset_id = None

assets = [
    MockAsset('CHAR_01', 'CHARACTER', 'subject', 8.0, True),
    MockAsset('CHAR_02', 'CHARACTER', 'subject', 7.0),
    MockAsset('ENV_01', 'ENVIRONMENT', 'background', 6.0),
    MockAsset('PROP_01', 'PROP', 'interaction_target', 5.0),
]

# Test close_up scene
manifest_json = {
    'scene_index': 0,
    'composition': {'shot_type': 'close_up', 'camera_movement': 'static', 'focal_point': 'CHAR_01'},
    'placements': [
        {'asset_tag': 'CHAR_01', 'role': 'subject', 'position': 'center'},
        {'asset_tag': 'ENV_01', 'role': 'background', 'position': 'background'},
    ],
}
result = select_references_for_scene(manifest_json, assets)
print(f'Close-up: {[a.manifest_tag for a in result]}')
assert len(result) <= 3
print('PASS')
"
```
  </verify>
  <done>Reference selection service exists with scene-type-aware logic. select_references_for_scene returns up to 3 assets prioritized by role and scene type. get_primary_clean_reference queries clean sheet table for primary override.</done>
</task>

</tasks>

<verification>
- `python -c "from vidpipe.db.models import AssetCleanReference; print(AssetCleanReference.__tablename__)"` prints "asset_clean_references"
- `python -c "from vidpipe.db.models import SceneManifest; print('selected_reference_tags' in [c.name for c in SceneManifest.__table__.columns])"` prints True
- `python -c "from vidpipe.services.reference_selection import select_references_for_scene, get_primary_clean_reference; print('OK')"` imports successfully
- Reference selection returns empty list for empty placements
- Reference selection returns at most 3 assets
- Close-up scene type prioritizes face crops
</verification>

<success_criteria>
1. AssetCleanReference model with all fields persists to database via metadata.create_all()
2. SceneManifest.selected_reference_tags stores list of manifest_tag strings as JSON
3. select_references_for_scene adapts selection by shot_type (close_up, two_shot, establishing, default)
4. get_primary_clean_reference returns clean sheet override or None
</success_criteria>

<output>
After completion, create `.planning/phases/08-veo-reference-passthrough-and-clean-sheets/08-01-SUMMARY.md`
</output>
