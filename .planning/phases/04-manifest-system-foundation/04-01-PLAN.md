---
phase: 04-manifest-system-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/vidpipe/db/models.py
  - backend/vidpipe/db/__init__.py
  - backend/vidpipe/services/manifest_service.py
  - backend/vidpipe/api/routes.py
  - backend/vidpipe/api/app.py
autonomous: true

must_haves:
  truths:
    - "Manifest records can be created, read, updated, and deleted via API"
    - "Asset records can be created within a manifest and listed via API"
    - "Projects can reference a manifest_id and manifest_version"
    - "Deleting a manifest used by active projects returns 409 Conflict"
    - "Manifest list supports category filtering and sort options"
    - "Image files can be uploaded to an asset within a manifest"
  artifacts:
    - path: "backend/vidpipe/db/models.py"
      provides: "Manifest and Asset ORM models with all fields from v2-manifest.md schema"
      contains: "class Manifest"
    - path: "backend/vidpipe/db/models.py"
      provides: "Asset ORM model with manifest_id FK"
      contains: "class Asset"
    - path: "backend/vidpipe/services/manifest_service.py"
      provides: "Business logic for manifest and asset CRUD operations"
      exports: ["create_manifest", "list_manifests", "get_manifest", "update_manifest", "delete_manifest", "create_asset", "list_assets", "upload_asset_image"]
    - path: "backend/vidpipe/api/routes.py"
      provides: "REST endpoints under /api/manifests with full CRUD"
      contains: "@router.post(\"/manifests\""
  key_links:
    - from: "backend/vidpipe/api/routes.py"
      to: "backend/vidpipe/services/manifest_service.py"
      via: "import and call service functions from route handlers"
      pattern: "from vidpipe\\.services\\.manifest_service import"
    - from: "backend/vidpipe/services/manifest_service.py"
      to: "backend/vidpipe/db/models.py"
      via: "SQLAlchemy queries against Manifest and Asset models"
      pattern: "select\\(Manifest\\)"
    - from: "backend/vidpipe/db/__init__.py"
      to: "backend/vidpipe/db/models.py"
      via: "migrations add manifest_id columns to projects table"
      pattern: "ALTER TABLE projects ADD COLUMN manifest_id"
---

<objective>
Create the complete backend for the Manifest System: database schema (Manifest and Asset models, Project table additions), business logic service layer, and REST API endpoints for full CRUD plus image upload.

Purpose: Establishes manifests as standalone, reusable entities with database persistence, a service layer for business logic, and HTTP endpoints that the frontend can consume.

Output: Manifest and Asset ORM models, manifest_service.py, 10+ API endpoints under /api/manifests, database migrations for new tables and Project column additions.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-manifest-system-foundation/04-RESEARCH.md
@backend/vidpipe/db/models.py
@backend/vidpipe/db/__init__.py
@backend/vidpipe/api/routes.py
@backend/vidpipe/api/app.py
@backend/vidpipe/services/file_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database models and migrations for Manifest, Asset, and Project additions</name>
  <files>
    backend/vidpipe/db/models.py
    backend/vidpipe/db/__init__.py
  </files>
  <action>
Add two new ORM models to `backend/vidpipe/db/models.py` following the existing SQLAlchemy 2.0 Mapped[Type] annotation pattern:

**Manifest model** (`__tablename__ = "manifests"`):
- `id: Mapped[uuid.UUID]` — primary key, default=uuid.uuid4
- `name: Mapped[str]` — Text, required
- `description: Mapped[Optional[str]]` — Text, nullable
- `thumbnail_url: Mapped[Optional[str]]` — String(500), nullable
- `category: Mapped[str]` — String(50), default="CUSTOM". Valid values: CHARACTERS, ENVIRONMENT, FULL_PRODUCTION, STYLE_KIT, BRAND_KIT, CUSTOM
- `tags: Mapped[Optional[list]]` — JSON, nullable
- `status: Mapped[str]` — String(50), default="DRAFT". Valid values: DRAFT, PROCESSING, READY, ERROR
- `processing_progress: Mapped[Optional[dict]]` — JSON, nullable
- `contact_sheet_url: Mapped[Optional[str]]` — String(500), nullable
- `asset_count: Mapped[int]` — Integer, default=0
- `total_processing_cost: Mapped[float]` — Float, default=0.0
- `times_used: Mapped[int]` — Integer, default=0
- `last_used_at: Mapped[Optional[datetime]]` — nullable
- `version: Mapped[int]` — Integer, default=1
- `parent_manifest_id: Mapped[Optional[uuid.UUID]]` — ForeignKey("manifests.id"), nullable, index=True
- `deleted_at: Mapped[Optional[datetime]]` — nullable (soft delete support per research recommendation)
- `created_at: Mapped[datetime]` — server_default=func.now()
- `updated_at: Mapped[datetime]` — server_default=func.now(), onupdate=func.now()

**Asset model** (`__tablename__ = "assets"`):
- `id: Mapped[uuid.UUID]` — primary key, default=uuid.uuid4
- `manifest_id: Mapped[uuid.UUID]` — ForeignKey("manifests.id"), index=True (CRITICAL: explicit index for query performance on SQLite)
- `asset_type: Mapped[str]` — String(50). Values: CHARACTER, OBJECT, ENVIRONMENT, PROP, STYLE, OTHER
- `name: Mapped[str]` — Text, required
- `manifest_tag: Mapped[str]` — String(50). Auto-generated tags like CHAR_01, OBJ_02, ENV_01
- `user_tags: Mapped[Optional[list]]` — JSON, nullable
- `reference_image_url: Mapped[Optional[str]]` — String(500), nullable (local path to uploaded image)
- `thumbnail_url: Mapped[Optional[str]]` — String(500), nullable
- `description: Mapped[Optional[str]]` — Text, nullable
- `source: Mapped[str]` — String(50), default="uploaded". Values: uploaded, detected, extracted
- `sort_order: Mapped[int]` — Integer, default=0 (for drag-drop reordering in Creator)
- `created_at: Mapped[datetime]` — server_default=func.now()

**Project model additions** — add two new columns to the existing Project class:
- `manifest_id: Mapped[Optional[uuid.UUID]]` — ForeignKey("manifests.id"), nullable=True, index=True
- `manifest_version: Mapped[Optional[int]]` — Integer, nullable=True

**In `backend/vidpipe/db/__init__.py`** — add idempotent ALTER TABLE migrations in `_run_migrations()`:
```python
"ALTER TABLE projects ADD COLUMN manifest_id TEXT REFERENCES manifests(id)",
"ALTER TABLE projects ADD COLUMN manifest_version INTEGER",
```

These follow the existing migration pattern (try/except to ignore "column already exists" errors). The new Manifest and Asset tables are created automatically by `Base.metadata.create_all`.

Do NOT add SQLAlchemy `relationship()` declarations — the existing codebase uses explicit queries, not lazy-loaded relationships.
  </action>
  <verify>
Run `python -c "from vidpipe.db.models import Manifest, Asset, Project; print('Manifest:', [c.name for c in Manifest.__table__.columns]); print('Asset:', [c.name for c in Asset.__table__.columns]); print('Project manifest_id:', 'manifest_id' in [c.name for c in Project.__table__.columns])"` from the backend directory. Should print all column names for Manifest and Asset models, and confirm manifest_id exists on Project.
  </verify>
  <done>
Manifest model has all 18 fields (id through updated_at including deleted_at). Asset model has all 12 fields (id through created_at). Project model has manifest_id and manifest_version columns. Migration SQL added to _run_migrations. All models use Mapped[Type] annotations consistent with existing codebase patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Manifest service layer and CRUD API endpoints with image upload</name>
  <files>
    backend/vidpipe/services/manifest_service.py
    backend/vidpipe/api/routes.py
    backend/vidpipe/api/app.py
  </files>
  <action>
**Create `backend/vidpipe/services/manifest_service.py`** — business logic layer (new file):

All functions accept an `AsyncSession` parameter (caller manages session). Follow the existing pattern where route handlers create sessions via `async with async_session() as session`.

Functions to implement:

1. `async def create_manifest(session, name, description=None, category="CUSTOM", tags=None) -> Manifest` — Create manifest with DRAFT status. Validate category is one of the 6 valid enum values, raise ValueError if not.

2. `async def list_manifests(session, category=None, status=None, sort_by="updated_at", sort_order="desc") -> list[Manifest]` — List non-deleted manifests (WHERE deleted_at IS NULL). Apply optional category and status filters. Support sort_by options: "updated_at", "created_at", "name", "times_used", "asset_count". Default desc order.

3. `async def get_manifest(session, manifest_id) -> Manifest | None` — Get single manifest by ID (only if deleted_at IS NULL).

4. `async def update_manifest(session, manifest_id, **kwargs) -> Manifest` — Update manifest fields. Only allow updating: name, description, category, tags. Validate category if provided. Raise ValueError if manifest not found.

5. `async def delete_manifest(session, manifest_id) -> None` — Soft delete (set deleted_at=func.now()). Check if any projects reference this manifest; if so, raise ValueError with count. If manifest not found, raise ValueError.

6. `async def duplicate_manifest(session, manifest_id, new_name=None) -> Manifest` — Create a copy with parent_manifest_id set, version=1, status=DRAFT. Copy all assets (with new UUIDs). If new_name not provided, use "{original_name} (Copy)".

7. `async def create_asset(session, manifest_id, name, asset_type, description=None, user_tags=None) -> Asset` — Create asset within manifest. Auto-generate manifest_tag by counting existing assets of the same type in this manifest and incrementing (e.g., if 2 CHARACTER assets exist, next gets CHAR_03). Type prefix map: CHARACTER->CHAR, OBJECT->OBJ, ENVIRONMENT->ENV, PROP->PROP, STYLE->STYLE, OTHER->OTHER. Update manifest.asset_count += 1 in same transaction.

8. `async def list_assets(session, manifest_id) -> list[Asset]` — List all assets for a manifest, ordered by sort_order then created_at.

9. `async def get_asset(session, asset_id) -> Asset | None` — Get single asset by ID.

10. `async def update_asset(session, asset_id, **kwargs) -> Asset` — Update asset fields: name, description, asset_type, user_tags, sort_order. If asset_type changes, regenerate manifest_tag.

11. `async def delete_asset(session, asset_id) -> None` — Hard delete asset. Update parent manifest.asset_count -= 1.

12. `async def save_asset_image(manifest_id, asset_id, file_content: bytes, filename: str) -> str` — Save uploaded image to `tmp/manifests/{manifest_id}/uploads/{asset_id}_{filename}`. Return the file path string. Use pathlib for path construction. Create directories if they don't exist. This function is NOT async (pure filesystem I/O wrapped in asyncio.to_thread by caller).

VALID_CATEGORIES constant: `{"CHARACTERS", "ENVIRONMENT", "FULL_PRODUCTION", "STYLE_KIT", "BRAND_KIT", "CUSTOM"}`
VALID_ASSET_TYPES constant: `{"CHARACTER", "OBJECT", "ENVIRONMENT", "PROP", "STYLE", "OTHER"}`
TAG_PREFIX_MAP: `{"CHARACTER": "CHAR", "OBJECT": "OBJ", "ENVIRONMENT": "ENV", "PROP": "PROP", "STYLE": "STYLE", "OTHER": "OTHER"}`

**Add API endpoints to `backend/vidpipe/api/routes.py`**:

Add Pydantic schemas at the top of the file (in the existing schemas section):

```python
class CreateManifestRequest(BaseModel):
    name: str
    description: Optional[str] = None
    category: str = "CUSTOM"
    tags: Optional[list[str]] = Field(default=None)

class UpdateManifestRequest(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    category: Optional[str] = None
    tags: Optional[list[str]] = None

class ManifestListItem(BaseModel):
    manifest_id: str
    name: str
    description: Optional[str]
    thumbnail_url: Optional[str]
    category: str
    tags: Optional[list[str]]
    status: str
    asset_count: int
    times_used: int
    last_used_at: Optional[str]
    version: int
    created_at: str
    updated_at: str

class ManifestDetailResponse(BaseModel):
    manifest_id: str
    name: str
    description: Optional[str]
    thumbnail_url: Optional[str]
    category: str
    tags: Optional[list[str]]
    status: str
    processing_progress: Optional[dict]
    contact_sheet_url: Optional[str]
    asset_count: int
    total_processing_cost: float
    times_used: int
    last_used_at: Optional[str]
    version: int
    parent_manifest_id: Optional[str]
    created_at: str
    updated_at: str
    assets: list["AssetResponse"]

class CreateAssetRequest(BaseModel):
    name: str
    asset_type: str
    description: Optional[str] = None
    user_tags: Optional[list[str]] = Field(default=None)

class UpdateAssetRequest(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    asset_type: Optional[str] = None
    user_tags: Optional[list[str]] = None
    sort_order: Optional[int] = None

class AssetResponse(BaseModel):
    asset_id: str
    manifest_id: str
    asset_type: str
    name: str
    manifest_tag: str
    user_tags: Optional[list[str]]
    reference_image_url: Optional[str]
    thumbnail_url: Optional[str]
    description: Optional[str]
    source: str
    sort_order: int
    created_at: str
```

Add these endpoints (all under the existing `router = APIRouter(prefix="/api")`):

1. `POST /manifests` (201) — Create manifest. Call manifest_service.create_manifest. Return ManifestListItem.
2. `GET /manifests` — List manifests. Query params: category (optional), status (optional), sort_by (default "updated_at"), sort_order (default "desc"). Return list[ManifestListItem].
3. `GET /manifests/{manifest_id}` — Get manifest detail with assets. Return ManifestDetailResponse (includes assets list).
4. `PUT /manifests/{manifest_id}` — Update manifest. Return ManifestListItem.
5. `DELETE /manifests/{manifest_id}` — Soft delete manifest. Return {"status": "deleted", "manifest_id": str}. Return 409 if used by projects.
6. `POST /manifests/{manifest_id}/duplicate` (201) — Duplicate manifest. Optional query param `name`. Return ManifestListItem.
7. `POST /manifests/{manifest_id}/assets` (201) — Create asset. Return AssetResponse.
8. `GET /manifests/{manifest_id}/assets` — List assets for manifest. Return list[AssetResponse].
9. `PUT /assets/{asset_id}` — Update asset. Return AssetResponse.
10. `DELETE /assets/{asset_id}` — Delete asset. Return {"status": "deleted", "asset_id": str}.
11. `POST /assets/{asset_id}/upload` (200) — Upload image file. Use `UploadFile` from FastAPI. Accept image/png, image/jpeg, image/webp (validate content_type). Max 10MB. Call save_asset_image via asyncio.to_thread, then update asset.reference_image_url in DB. Return AssetResponse with updated reference_image_url.

Each route handler creates its own session with `async with async_session() as session:` per existing pattern. Convert ValueError from service to HTTPException(422). Convert "not found" cases to HTTPException(404).

Helper function `_manifest_to_list_item(m: Manifest) -> ManifestListItem` and `_asset_to_response(a: Asset) -> AssetResponse` to avoid repetition.

**In `backend/vidpipe/api/app.py`** — No changes needed if routes.py uses the same router. But verify that the existing `app.include_router(router)` already picks up the new routes (it does, since they're added to the same router instance).

Import `UploadFile, File` from fastapi and `asyncio` in routes.py. Import from `vidpipe.services.manifest_service` all needed functions.
  </action>
  <verify>
Start the API server and test with curl:
```bash
# Create manifest
curl -s -X POST http://localhost:8000/api/manifests -H "Content-Type: application/json" -d '{"name":"Test Manifest","category":"CHARACTERS"}' | python -m json.tool

# List manifests
curl -s http://localhost:8000/api/manifests | python -m json.tool

# Create asset within manifest (use manifest_id from above)
curl -s -X POST http://localhost:8000/api/manifests/{MANIFEST_ID}/assets -H "Content-Type: application/json" -d '{"name":"Hero Character","asset_type":"CHARACTER"}' | python -m json.tool

# Get manifest detail with assets
curl -s http://localhost:8000/api/manifests/{MANIFEST_ID} | python -m json.tool

# Delete manifest
curl -s -X DELETE http://localhost:8000/api/manifests/{MANIFEST_ID} | python -m json.tool
```
All 11 endpoints return correct status codes and response shapes. Manifest CRUD works end-to-end. Asset creation auto-generates manifest_tag (CHAR_01). Delete returns 409 when manifest is referenced by a project.
  </verify>
  <done>
11 API endpoints operational under /api/manifests. Service layer handles all business logic (validation, auto-tagging, soft delete, duplication). Image upload saves to tmp/manifests/{id}/uploads/. All endpoints use fresh async sessions per request. Pydantic schemas validate input and serialize output.
  </done>
</task>

</tasks>

<verification>
1. Database schema: `python -c "from vidpipe.db.models import Manifest, Asset"` succeeds
2. API server starts without errors: `python -m vidpipe.api`
3. Manifest CRUD: POST, GET, PUT, DELETE all return expected status codes
4. Asset CRUD: POST, GET (list), PUT, DELETE all work within manifest scope
5. Auto-tagging: Creating two CHARACTER assets produces CHAR_01, CHAR_02
6. Soft delete: Deleted manifests excluded from list, returns 409 if referenced by projects
7. Image upload: POST /assets/{id}/upload with multipart file saves to disk and updates reference_image_url
8. Duplication: POST /manifests/{id}/duplicate creates copy with all assets
</verification>

<success_criteria>
- Manifest table stores all fields from v2-manifest.md schema
- Asset table with manifest_id FK and index
- Project table has manifest_id and manifest_version columns
- 11 REST endpoints under /api/manifests fully operational
- Service layer encapsulates business logic
- Image upload works with multipart form data
- Soft delete prevents accidental data loss
</success_criteria>

<output>
After completion, create `.planning/phases/04-manifest-system-foundation/04-01-SUMMARY.md`
</output>
