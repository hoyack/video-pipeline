---
phase: 02-generation-pipeline
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - vidpipe/pipeline/stitcher.py
  - vidpipe/__init__.py
autonomous: true
user_setup:
  - service: ffmpeg
    why: "Video concatenation and crossfade transitions"
    installation:
      - method: "System package manager"
        commands:
          ubuntu: "sudo apt-get install ffmpeg"
          macos: "brew install ffmpeg"
          windows: "Download from https://ffmpeg.org/download.html"
    validation:
      - command: "ffmpeg -version"
        expected: "ffmpeg version"

must_haves:
  truths:
    - "All completed clips are concatenated into single MP4 with hard cuts or crossfade transitions"
    - "Audio streams from Veo are preserved during concatenation"
    - "Final output saved to tmp/{project_id}/output/final.mp4"
    - "ffmpeg is validated at startup with clear error if missing"
  artifacts:
    - path: "vidpipe/pipeline/stitcher.py"
      provides: "Video stitching with ffmpeg concat demuxer and xfade filter"
      exports: ["stitch_videos"]
      min_lines: 100
    - path: "vidpipe/__init__.py"
      provides: "Startup validation for ffmpeg availability"
      exports: ["validate_dependencies"]
      min_lines: 20
  key_links:
    - from: "vidpipe/pipeline/stitcher.py"
      to: "vidpipe/services/file_manager.py"
      via: "FileManager to get output path"
      pattern: "FileManager\\(\\)"
    - from: "vidpipe/pipeline/stitcher.py"
      to: "subprocess.run"
      via: "ffmpeg command execution"
      pattern: "subprocess\\.run.*ffmpeg"
    - from: "vidpipe/__init__.py"
      to: "subprocess.run"
      via: "ffmpeg -version validation"
      pattern: "subprocess\\.run.*ffmpeg.*-version"
---

<objective>
Implement video stitching using ffmpeg concat demuxer for hard cuts and xfade filter for crossfade transitions, with startup validation to ensure ffmpeg is available before any generation work begins.

Purpose: Combines individual scene clips into a cohesive final video, completing the generation pipeline and producing the deliverable MP4 file.

Output: Video stitcher with concat/crossfade support and ffmpeg startup validation.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-generation-pipeline/02-RESEARCH.md
@.planning/phases/02-generation-pipeline/02-01-SUMMARY.md
@.planning/phases/02-generation-pipeline/02-02-SUMMARY.md
@.planning/phases/02-generation-pipeline/02-03-SUMMARY.md
@docs/spec.md
@vidpipe/db/models.py
@vidpipe/config.py
@vidpipe/services/file_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ffmpeg startup validation</name>
  <files>vidpipe/__init__.py</files>
  <action>
Create startup validation function to check ffmpeg availability per STCH-05 requirement.

Implementation:

1. Import subprocess, logging

2. Create function:
   ```python
   def validate_dependencies() -> None:
       """Validate required system dependencies are available.

       Raises:
           RuntimeError: If ffmpeg is not found or not functional.
       """
       try:
           result = subprocess.run(
               ['ffmpeg', '-version'],
               capture_output=True,
               check=True,
               text=True
           )
           version_line = result.stdout.split('\n')[0]
           logger.info(f"ffmpeg validated: {version_line}")
       except (subprocess.CalledProcessError, FileNotFoundError) as e:
           raise RuntimeError(
               "ffmpeg not found on PATH. Install ffmpeg to use video generation pipeline.\n"
               "Ubuntu/Debian: sudo apt-get install ffmpeg\n"
               "macOS: brew install ffmpeg\n"
               "Windows: https://ffmpeg.org/download.html"
           ) from e
   ```

3. Add module docstring explaining this should be called during application startup

Per research Pitfall 1: Validate at startup, not during pipeline execution, to fail fast with clear error message.

Do NOT catch the RuntimeError — let it bubble up to stop application initialization if ffmpeg is missing.
  </action>
  <verify>
Test ffmpeg validation:
```bash
python -c "from vidpipe import validate_dependencies; validate_dependencies(); print('OK')"
```

Should print "OK" if ffmpeg is installed, or raise RuntimeError with installation instructions if missing.
  </verify>
  <done>
vidpipe/__init__.py exists, exports validate_dependencies(), checks ffmpeg -version, raises RuntimeError with installation instructions if missing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement video stitching with concat demuxer and xfade support</name>
  <files>vidpipe/pipeline/stitcher.py</files>
  <action>
Create async video stitcher implementing STCH-01 through STCH-04 requirements.

Function signature: `async def stitch_videos(session: AsyncSession, project: Project) -> None`

Implementation (following research Code Example 4 - ffmpeg concatenation):

1. Imports:
   - from vidpipe.services.file_manager import FileManager
   - from vidpipe.db.models import VideoClip, Scene
   - from vidpipe.config import settings
   - from sqlalchemy import select
   - import subprocess
   - from pathlib import Path
   - import asyncio

2. Get file manager: `file_mgr = FileManager()`

3. Query completed clips:
   ```python
   result = await session.execute(
       select(VideoClip)
       .join(Scene)
       .where(Scene.project_id == project.id)
       .where(VideoClip.status == "complete")
       .order_by(Scene.scene_index)
   )
   clips = result.scalars().all()
   ```

4. If no clips available:
   ```python
   if not clips:
       project.status = "failed"
       project.error_message = "No completed video clips available for stitching"
       await session.commit()
       return
   ```

5. Get clip paths: `clip_paths = [Path(clip.local_path) for clip in clips]`

6. Get output path: `output_path = file_mgr.get_output_path(project.id, "final.mp4")`

7. Determine stitching mode based on settings.pipeline.crossfade_seconds:
   - If crossfade_seconds == 0.0: Use concat demuxer (STCH-01)
   - Else: Use xfade filter (STCH-02)

8. Call stitching helper, then update project:
   ```python
   if settings.pipeline.crossfade_seconds == 0.0:
       await asyncio.to_thread(_stitch_concat_demuxer, clip_paths, output_path)
   else:
       await asyncio.to_thread(
           _stitch_with_crossfade,
           clip_paths,
           output_path,
           settings.pipeline.crossfade_seconds,
           project.target_clip_duration
       )

   project.output_path = str(output_path)
   project.status = "complete"
   await session.commit()
   ```

Helper functions (private module functions):

`def _stitch_concat_demuxer(clip_paths: list[Path], output_path: Path) -> None:`
```python
# Create concat list file (STCH-04)
list_file = output_path.parent / "concat_list.txt"
with open(list_file, 'w') as f:
    for clip_path in clip_paths:
        f.write(f"file '{clip_path.resolve()}'\n")

# Run ffmpeg concat (STCH-01, STCH-03)
subprocess.run([
    'ffmpeg', '-y',
    '-f', 'concat',
    '-safe', '0',  # CRITICAL: Allow absolute paths (Pitfall 7)
    '-i', str(list_file),
    '-c', 'copy',  # Stream copy preserves audio (STCH-03)
    str(output_path)
], check=True, capture_output=True)

list_file.unlink()  # Clean up
```

`def _stitch_with_crossfade(clip_paths: list[Path], output_path: Path, crossfade_duration: float, clip_duration: int) -> None:`
```python
# Build input arguments
inputs = []
for clip_path in clip_paths:
    inputs.extend(['-i', str(clip_path)])

# Build xfade filter chain (STCH-02)
if len(clip_paths) == 1:
    # Single clip, no crossfade needed
    subprocess.run([
        'ffmpeg', '-y',
        '-i', str(clip_paths[0]),
        '-c', 'copy',
        str(output_path)
    ], check=True, capture_output=True)
    return

filter_parts = []
prev_label = "0:v"

for i in range(1, len(clip_paths)):
    out_label = f"v{i:02d}"
    offset = (i * clip_duration) - (crossfade_duration * i)
    filter_parts.append(
        f"[{prev_label}][{i}:v]xfade=transition=fade:"
        f"duration={crossfade_duration}:offset={offset}[{out_label}]"
    )
    prev_label = out_label

filter_complex = ";".join(filter_parts)

# Run ffmpeg with xfade (requires re-encoding)
subprocess.run([
    'ffmpeg', '-y',
    *inputs,
    '-filter_complex', filter_complex,
    '-map', f"[{prev_label}]",
    '-vsync', 'vfr',
    str(output_path)
], check=True, capture_output=True)
```

Per research Code Example 4 (ffmpeg patterns), Pitfall 7 (absolute paths with -safe 0), Pattern 1 (async state machine).

CRITICAL: Use `await asyncio.to_thread()` to run subprocess in thread pool, preventing event loop blocking.

Do NOT use `-safe 1` (default) — use `-safe 0` to allow absolute paths in concat list.
  </action>
  <verify>
Unit test or manual test:
```python
from vidpipe.pipeline.stitcher import stitch_videos
from vidpipe.db import async_session
from vidpipe.db.models import Project
from sqlalchemy import select
from pathlib import Path
import asyncio

async def test():
    async with async_session() as session:
        # Assume project with completed clips exists from Plan 02-03
        result = await session.execute(select(Project).limit(1))
        project = result.scalar_one()
        project.status = "stitching"
        await session.commit()

        await stitch_videos(session, project)

        print(f"Project status: {project.status}")
        print(f"Output path: {project.output_path}")
        print(f"File exists: {Path(project.output_path).exists() if project.output_path else False}")

asyncio.run(test())
```

Should create final.mp4 in tmp/{project_id}/output/, project status = "complete", output_path populated.
  </verify>
  <done>
vidpipe/pipeline/stitcher.py exists, exports stitch_videos(), uses ffmpeg concat demuxer for hard cuts, uses xfade filter for crossfades, preserves audio streams, saves to tmp/{project_id}/output/final.mp4, updates project status to "complete".

vidpipe/__init__.py updated with validate_dependencies() for ffmpeg validation.
  </done>
</task>

</tasks>

<verification>
End-to-end test:
1. Run validate_dependencies() at startup — should pass if ffmpeg installed
2. Create project with 3 completed video clips
3. Run stitch_videos()
4. Verify: final.mp4 exists at tmp/{project_id}/output/final.mp4
5. Verify: Project status = "complete", output_path populated
6. Verify: ffplay or vlc can play the final video
7. Test with crossfade_seconds=0.0 (concat demuxer) and crossfade_seconds=0.5 (xfade filter)
</verification>

<success_criteria>
- [x] ffmpeg startup validation implemented (STCH-05)
- [x] validate_dependencies() raises RuntimeError with install instructions if ffmpeg missing
- [x] Concat demuxer used for hard cuts when crossfade_seconds=0.0 (STCH-01)
- [x] xfade filter used for crossfade transitions when crossfade_seconds>0.0 (STCH-02)
- [x] Audio streams preserved during concatenation (STCH-03)
- [x] Final output saved to tmp/{project_id}/output/final.mp4 (STCH-04)
- [x] Concat list uses absolute paths with -safe 0 flag
- [x] Subprocess calls wrapped in asyncio.to_thread() to prevent blocking
- [x] Project status updated to "complete" after successful stitching
- [x] Handles single clip case (no crossfade needed)
- [x] Handles case with no completed clips (marks project as failed)
</success_criteria>

<output>
After completion, create `.planning/phases/02-generation-pipeline/02-04-SUMMARY.md`
</output>
