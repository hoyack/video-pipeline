---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - vidpipe/db/engine.py
  - vidpipe/services/file_manager.py
  - vidpipe/db/__init__.py
autonomous: true

must_haves:
  truths:
    - "SQLite database initializes with WAL mode enabled"
    - "Foreign keys are enabled on every database connection"
    - "Database engine uses synchronous=FULL for crash safety"
    - "Async sessions have expire_on_commit=False to prevent lazy loading errors"
    - "File manager creates structured directories (keyframes/, clips/, output/) per project"
    - "Database schema can be created from models using metadata.create_all()"
  artifacts:
    - path: "vidpipe/db/engine.py"
      provides: "Async engine with WAL configuration and session factory"
      min_lines: 50
      contains: "PRAGMA journal_mode=WAL"
    - path: "vidpipe/services/file_manager.py"
      provides: "Filesystem artifact management with pathlib"
      min_lines: 40
      contains: "class FileManager"
    - path: "vidpipe/db/__init__.py"
      provides: "Database initialization function"
      contains: "async def init_database"
  key_links:
    - from: "vidpipe/db/engine.py"
      to: "aiosqlite connection"
      via: "event listener for PRAGMA configuration"
      pattern: "@event.listens_for.*connect"
    - from: "vidpipe/db/engine.py"
      to: "async_sessionmaker"
      via: "session factory with expire_on_commit=False"
      pattern: "expire_on_commit=False"
    - from: "vidpipe/services/file_manager.py"
      to: "vidpipe.config.settings"
      via: "import for base tmp_dir"
      pattern: "from vidpipe.config import settings"
---

<objective>
Implement crash-safe SQLite database engine with WAL mode and structured filesystem artifact storage.

Purpose: Create the data persistence and file management foundation that ensures crash recovery and prevents database corruption.
Output: Working async database engine with PRAGMA configuration and file manager service.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/ubuntu/work/video-pipeline/.planning/PROJECT.md
@/home/ubuntu/work/video-pipeline/.planning/ROADMAP.md
@/home/ubuntu/work/video-pipeline/.planning/STATE.md
@/home/ubuntu/work/video-pipeline/.planning/phases/01-foundation/01-RESEARCH.md
@/home/ubuntu/work/video-pipeline/docs/spec.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create async engine with WAL mode and PRAGMA configuration</name>
  <files>vidpipe/db/engine.py</files>
  <action>
Create vidpipe/db/engine.py following research Pattern 1 and Pattern 3:

1. Define configure_sqlite_pragmas function:
   - Takes dbapi_conn, connection_record parameters
   - Creates cursor
   - Executes PRAGMA journal_mode=WAL
   - Executes PRAGMA synchronous=FULL (per FOUND-04 requirement for crash safety)
   - Executes PRAGMA foreign_keys=ON (critical per research Pitfall 2)
   - Executes PRAGMA busy_timeout=5000
   - Closes cursor

2. Create async engine:
   - from vidpipe.config import settings
   - engine = create_async_engine(settings.storage.database_url, echo=False)
   - Use @event.listens_for(engine.sync_engine, "connect") decorator with configure_sqlite_pragmas
   - CRITICAL: Use engine.sync_engine for event listener, not engine directly (aiosqlite wraps sync engine)

3. Create async_session factory:
   - async_session = async_sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)
   - CRITICAL: expire_on_commit=False per research Pitfall 1 to prevent greenlet errors

4. Create get_session dependency injection function:
   - async def get_session() -> AsyncSession
   - async with async_session() as session: yield session

5. Create shutdown function:
   - async def shutdown(): await engine.dispose()

Use imports: create_async_engine, async_sessionmaker, AsyncSession from sqlalchemy.ext.asyncio, event from sqlalchemy.

Follow research examples exactly - do not use engine.begin() in event listener, use cursor.execute() directly.
  </action>
  <verify>
python -c "import asyncio; from vidpipe.db.engine import engine, async_session; print('Engine created successfully')"
python -c "import asyncio; from vidpipe.db.engine import async_session; asyncio.run(async_session().__anext__()); print('Session factory works')"
  </verify>
  <done>
vidpipe/db/engine.py exists with async engine configured for WAL mode, PRAGMA event listener registered, async_sessionmaker with expire_on_commit=False, get_session and shutdown functions defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement FileManager service with structured directories</name>
  <files>vidpipe/services/file_manager.py</files>
  <action>
Create vidpipe/services/file_manager.py following research Pattern 5:

1. Create FileManager class:
   - __init__(self, base_dir: str | Path | None = None):
     - If base_dir is None, use settings.storage.tmp_dir
     - self.base_dir = Path(base_dir).resolve()
     - self.base_dir.mkdir(parents=True, exist_ok=True)

2. Implement get_project_dir(self, project_id: uuid.UUID) -> Path:
   - project_dir = (self.base_dir / str(project_id)).resolve()
   - Validate project_dir.is_relative_to(self.base_dir) to prevent path traversal (per research Pitfall 5)
   - If not relative, raise ValueError("Invalid project path")
   - project_dir.mkdir(exist_ok=True)
   - Create subdirectories: (project_dir / "keyframes").mkdir(exist_ok=True), same for "clips" and "output"
   - Return project_dir

3. Implement save_keyframe(self, project_id: uuid.UUID, scene_idx: int, position: str, data: bytes) -> Path:
   - project_dir = self.get_project_dir(project_id)
   - filename = f"scene_{scene_idx}_{position}.png"
   - filepath = project_dir / "keyframes" / filename
   - filepath.write_bytes(data) (atomic write per research Pattern 5)
   - Return filepath

4. Implement save_clip(self, project_id: uuid.UUID, scene_idx: int, data: bytes) -> Path:
   - Similar to save_keyframe but saves to clips/ directory
   - filename = f"scene_{scene_idx}.mp4"

5. Implement get_output_path(self, project_id: uuid.UUID, filename: str = "final.mp4") -> Path:
   - project_dir = self.get_project_dir(project_id)
   - Return project_dir / "output" / filename

Use imports: Path from pathlib, uuid, from vidpipe.config import settings

Add docstrings to all methods explaining purpose and path traversal protection.
  </action>
  <verify>
python -c "from vidpipe.services.file_manager import FileManager; import uuid; fm = FileManager(); project_id = uuid.uuid4(); path = fm.get_project_dir(project_id); assert path.exists(); assert (path / 'keyframes').exists(); print(f'Created project dir: {path}')"
python -c "from vidpipe.services.file_manager import FileManager; import uuid; fm = FileManager(); kf = fm.save_keyframe(uuid.uuid4(), 0, 'start', b'test'); assert kf.exists(); print('Keyframe saved')"
  </verify>
  <done>
FileManager class exists with get_project_dir, save_keyframe, save_clip, and get_output_path methods, path traversal protection implemented, methods create structured subdirectories
  </done>
</task>

<task type="auto">
  <name>Task 3: Create database initialization function</name>
  <files>vidpipe/db/__init__.py</files>
  <action>
Update vidpipe/db/__init__.py following research Pattern 6:

1. Add imports:
   - from vidpipe.db.models import Base
   - from vidpipe.db.engine import engine, async_session, shutdown

2. Implement async init_database() function:
   ```python
   async def init_database():
       """Initialize database schema on first run."""
       async with engine.begin() as conn:
           await conn.run_sync(Base.metadata.create_all)
   ```

3. Export all public symbols:
   - __all__ = ["Base", "engine", "async_session", "get_session", "shutdown", "init_database"]

4. Add module docstring:
   """
   Database module for vidpipe.

   Provides async SQLAlchemy engine with SQLite WAL mode,
   session management, and schema initialization.
   """

Follow research Pattern 6 exactly - use conn.run_sync(Base.metadata.create_all) to run sync metadata operation in async context.

Do NOT use Alembic for v1 per research Open Question 1 - use metadata.create_all() for simplicity.
  </action>
  <verify>
python -c "import asyncio; from vidpipe.db import init_database; asyncio.run(init_database()); print('Database initialized')"
ls vidpipe.db && echo "Database file created"
python -c "import sqlite3; conn = sqlite3.connect('vidpipe.db'); cursor = conn.execute('PRAGMA journal_mode'); mode = cursor.fetchone()[0]; assert mode == 'wal', f'Expected WAL mode, got {mode}'; print('WAL mode verified')"
  </verify>
  <done>
vidpipe/db/__init__.py exports init_database function, running init_database creates vidpipe.db with all tables, database uses WAL mode, all 5 tables exist (projects, scenes, keyframes, video_clips, pipeline_runs)
  </done>
</task>

</tasks>

<verification>
1. Run database initialization: python -c "import asyncio; from vidpipe.db import init_database; asyncio.run(init_database())"
2. Verify WAL mode: python -c "import sqlite3; conn = sqlite3.connect('vidpipe.db'); print(conn.execute('PRAGMA journal_mode').fetchone())"
3. Verify foreign keys enabled: python -c "import sqlite3; conn = sqlite3.connect('vidpipe.db'); print(conn.execute('PRAGMA foreign_keys').fetchone())"
4. Check tables exist: python -c "import sqlite3; conn = sqlite3.connect('vidpipe.db'); tables = [row[0] for row in conn.execute('SELECT name FROM sqlite_master WHERE type=\"table\"')]; assert len(tables) == 5; print(f'Tables: {tables}')"
5. Test file manager: python -c "from vidpipe.services.file_manager import FileManager; import uuid; fm = FileManager(); project_id = uuid.uuid4(); kf = fm.save_keyframe(project_id, 0, 'start', b'test'); print(f'Saved to: {kf}')"
</verification>

<success_criteria>
- vidpipe/db/engine.py creates async engine with WAL mode enabled via event listener
- PRAGMA synchronous=FULL and foreign_keys=ON are set on every connection
- async_sessionmaker uses expire_on_commit=False
- vidpipe/services/file_manager.py implements FileManager with path traversal protection
- FileManager creates keyframes/, clips/, output/ subdirectories per project
- vidpipe/db/__init__.py exports init_database function that creates schema
- Running init_database() creates vidpipe.db with all 5 tables in WAL mode
- Database survives crashes without corruption (WAL + synchronous=FULL)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
