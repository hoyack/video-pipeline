---
phase: 07-manifest-aware-storyboarding-and-audio-manifest
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/vidpipe/schemas/storyboard_enhanced.py
  - backend/vidpipe/db/models.py
  - backend/vidpipe/db/__init__.py
autonomous: true

must_haves:
  truths:
    - "Enhanced Pydantic schemas define SceneManifest with asset placements, composition, and continuity"
    - "Enhanced Pydantic schemas define SceneAudioManifest with dialogue, SFX, ambient, music, and audio continuity"
    - "EnhancedStoryboardOutput extends existing StoryboardOutput with scene_manifest and audio_manifest per scene"
    - "SceneManifest and SceneAudioManifest ORM models exist with composite primary key (project_id, scene_index)"
    - "Database migrations create both tables idempotently"
  artifacts:
    - path: "backend/vidpipe/schemas/storyboard_enhanced.py"
      provides: "Pydantic schemas for manifest-aware storyboard output"
      exports: ["AssetPlacement", "SceneComposition", "DialogueLine", "SFXEntry", "AmbientAudio", "MusicDirection", "AudioContinuity", "SceneManifestSchema", "SceneAudioManifestSchema", "EnhancedSceneSchema", "EnhancedStoryboardOutput"]
    - path: "backend/vidpipe/db/models.py"
      provides: "SceneManifest and SceneAudioManifest ORM models"
      contains: "class SceneManifest"
    - path: "backend/vidpipe/db/__init__.py"
      provides: "Idempotent migration for scene_manifests and scene_audio_manifests tables"
  key_links:
    - from: "backend/vidpipe/schemas/storyboard_enhanced.py"
      to: "backend/vidpipe/schemas/storyboard.py"
      via: "EnhancedSceneSchema inherits from SceneSchema"
      pattern: "class EnhancedSceneSchema\\(SceneSchema\\)"
    - from: "backend/vidpipe/schemas/storyboard_enhanced.py"
      to: "backend/vidpipe/schemas/storyboard.py"
      via: "EnhancedStoryboardOutput uses StyleGuide and CharacterDescription"
      pattern: "from vidpipe\\.schemas\\.storyboard import"
---

<objective>
Create Pydantic schemas for manifest-aware storyboard output and database models for scene manifests and audio manifests.

Purpose: Establishes the data layer foundation that Plan 02 needs to enhance the storyboard pipeline. Schemas define the structure Gemini will produce (via response_schema), and ORM models define where that structured data is persisted.

Output: New schemas file (storyboard_enhanced.py), two new ORM models (SceneManifest, SceneAudioManifest), and idempotent migrations.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-manifest-aware-storyboarding-and-audio-manifest/07-RESEARCH.md
@backend/vidpipe/schemas/storyboard.py
@backend/vidpipe/db/models.py
@backend/vidpipe/db/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create enhanced Pydantic schemas for manifest-aware storyboard output</name>
  <files>backend/vidpipe/schemas/storyboard_enhanced.py</files>
  <action>
Create a new file `backend/vidpipe/schemas/storyboard_enhanced.py` with the following Pydantic models, all importing from pydantic BaseModel and Field:

1. **AssetPlacement(BaseModel):** Fields: asset_tag (str, description="Manifest tag e.g. CHAR_01, ENV_02"), role (str, description="subject | background | prop | interaction_target | environment"), position (str, description="Spatial hint: center, left, right, foreground, background"), action (Optional[str], default=None, description="What asset does in scene"), expression (Optional[str], default=None, description="For characters: facial expression, body language"), wardrobe_note (Optional[str], default=None, description="Clothing/appearance notes for continuity").

2. **SceneComposition(BaseModel):** Fields: shot_type (str, description="wide_shot | medium_shot | close_up | two_shot | establishing"), camera_movement (str, description="static | slow_pan_left | dolly_forward | crane_up | tracking"), focal_point (str, description="What camera focuses on (asset tag or description)").

3. **DialogueLine(BaseModel):** Fields: speaker_tag (str, description="Character asset tag e.g. CHAR_01"), speaker_name (str, description="Character name for readability"), line (str, description="Exact dialogue text"), delivery (Optional[str], default=None, description="How said: muttered, shouted, whispered"), timing (str, description="When in scene: start | mid-scene | end"), emphasis (Optional[list[str]], default=None, description="Words to emphasize").

4. **SFXEntry(BaseModel):** Fields: effect (str), trigger (str, description="What causes the sound"), timing (str, description="Relative timing e.g. mid-scene, throughout, 0:02-0:04"), volume (str, description="subtle | prominent | background").

5. **AmbientAudio(BaseModel):** Fields: base_layer (str), environmental (Optional[str], default=None), weather (Optional[str], default=None), time_cues (Optional[str], default=None).

6. **MusicDirection(BaseModel):** Fields: style (str), mood (str), tempo (str, description="slow | moderate | fast | accelerating"), instruments (Optional[list[str]], default=None), transition (str, description="How music enters/exits: fade in, cut, swell").

7. **AudioContinuity(BaseModel):** Fields: carries_from_previous (list[str], default_factory=list), new_in_this_scene (list[str], default_factory=list), cuts_from_previous (list[str], default_factory=list).

8. **SceneManifestSchema(BaseModel):** Fields: scene_index (int), composition (SceneComposition), placements (list[AssetPlacement], description="All assets in this scene"), continuity_notes (Optional[str], default=None), new_asset_declarations (Optional[list[dict]], default=None, description="Assets not in registry: [{name, type, description}]").

9. **SceneAudioManifestSchema(BaseModel):** Fields: scene_index (int), dialogue_lines (list[DialogueLine], default_factory=list), sfx (list[SFXEntry], default_factory=list), ambient (Optional[AmbientAudio], default=None), music (Optional[MusicDirection], default=None), audio_continuity (Optional[AudioContinuity], default=None).

10. **EnhancedSceneSchema(SceneSchema):** Import SceneSchema from vidpipe.schemas.storyboard. Add two fields: scene_manifest (SceneManifestSchema), audio_manifest (SceneAudioManifestSchema).

11. **EnhancedStoryboardOutput(BaseModel):** Import StyleGuide, CharacterDescription from vidpipe.schemas.storyboard. Fields: style_guide (StyleGuide), characters (list[CharacterDescription]), scenes (list[EnhancedSceneSchema]). This is NOT a subclass of StoryboardOutput -- it's a separate model because the scenes field type differs (EnhancedSceneSchema vs SceneSchema).

Add module docstring explaining these schemas extend the base storyboard schemas with manifest and audio manifest support, and are used when project.manifest_id is set.

All Field() calls MUST include description= parameter because Gemini uses Field descriptions to guide structured output generation (established pattern from Phase 2).
  </action>
  <verify>
Run: `cd /home/ubuntu/work/video-pipeline/backend && python -c "from vidpipe.schemas.storyboard_enhanced import EnhancedStoryboardOutput, SceneManifestSchema, SceneAudioManifestSchema, AssetPlacement, DialogueLine, SFXEntry, AmbientAudio, MusicDirection, AudioContinuity, SceneComposition, EnhancedSceneSchema; print('All schemas import OK'); print(f'EnhancedStoryboardOutput fields: {list(EnhancedStoryboardOutput.model_fields.keys())}'); print(f'SceneManifestSchema fields: {list(SceneManifestSchema.model_fields.keys())}'); print(f'SceneAudioManifestSchema fields: {list(SceneAudioManifestSchema.model_fields.keys())}')"`
  </verify>
  <done>All 11 Pydantic models import successfully. EnhancedStoryboardOutput has style_guide, characters, scenes fields. SceneManifestSchema has scene_index, composition, placements, continuity_notes, new_asset_declarations. SceneAudioManifestSchema has scene_index, dialogue_lines, sfx, ambient, music, audio_continuity. EnhancedSceneSchema inherits from SceneSchema and adds scene_manifest and audio_manifest.</done>
</task>

<task type="auto">
  <name>Task 2: Add SceneManifest and SceneAudioManifest ORM models with idempotent migration</name>
  <files>backend/vidpipe/db/models.py, backend/vidpipe/db/__init__.py</files>
  <action>
**In backend/vidpipe/db/models.py**, add two new ORM models AFTER the Scene class (since they reference projects table):

1. **SceneManifest(Base):** Table name "scene_manifests". Composite primary key on (project_id, scene_index). Columns:
   - project_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("projects.id"), primary_key=True)
   - scene_index: Mapped[int] = mapped_column(Integer, primary_key=True)
   - manifest_json: Mapped[dict] = mapped_column(JSON)  # Full SceneManifestSchema.model_dump()
   - composition_shot_type: Mapped[Optional[str]] = mapped_column(String(50), nullable=True)  # Denormalized for queries
   - composition_camera_movement: Mapped[Optional[str]] = mapped_column(String(50), nullable=True)
   - asset_tags: Mapped[Optional[list]] = mapped_column(JSON, nullable=True)  # Array of referenced tags
   - new_asset_count: Mapped[int] = mapped_column(Integer, default=0)
   - created_at: Mapped[datetime] = mapped_column(server_default=func.now())

   Docstring: "Per-scene asset placement manifest with composition metadata. Spec reference: Phase 7"

2. **SceneAudioManifest(Base):** Table name "scene_audio_manifests". Composite primary key on (project_id, scene_index). Columns:
   - project_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("projects.id"), primary_key=True)
   - scene_index: Mapped[int] = mapped_column(Integer, primary_key=True)
   - dialogue_json: Mapped[Optional[list]] = mapped_column(JSON, nullable=True)  # Array of DialogueLine dicts
   - sfx_json: Mapped[Optional[list]] = mapped_column(JSON, nullable=True)  # Array of SFXEntry dicts
   - ambient_json: Mapped[Optional[dict]] = mapped_column(JSON, nullable=True)  # AmbientAudio dict
   - music_json: Mapped[Optional[dict]] = mapped_column(JSON, nullable=True)  # MusicDirection dict
   - audio_continuity_json: Mapped[Optional[dict]] = mapped_column(JSON, nullable=True)  # AudioContinuity dict
   - speaker_tags: Mapped[Optional[list]] = mapped_column(JSON, nullable=True)  # Denormalized dialogue speakers
   - has_dialogue: Mapped[bool] = mapped_column(Boolean, default=False)
   - has_music: Mapped[bool] = mapped_column(Boolean, default=False)
   - created_at: Mapped[datetime] = mapped_column(server_default=func.now())

   Docstring: "Per-scene audio direction manifest with dialogue, SFX, ambient, and music. Spec reference: Phase 7"

Note: SQLite does not support GIN indexes or TEXT[] arrays. Use JSON columns for arrays (asset_tags, speaker_tags) — this follows the existing pattern used by Manifest.tags (JSON column storing lists). Do NOT add GIN indexes (they're PostgreSQL-only). SQLite indexes on JSON columns are not beneficial, so skip them.

**In backend/vidpipe/db/__init__.py**, add idempotent CREATE TABLE IF NOT EXISTS for both tables. Follow the existing Phase 5 migration pattern: use `inspector.has_table()` check or raw SQL `CREATE TABLE IF NOT EXISTS`. The init_database function likely uses metadata.create_all() which handles this automatically via SQLAlchemy — verify by reading the current __init__.py and follow the established pattern. If metadata.create_all() is used, the new models will be auto-created since they inherit from Base. Just ensure the models are imported so they're registered in Base.metadata.
  </action>
  <verify>
Run: `cd /home/ubuntu/work/video-pipeline/backend && python -c "from vidpipe.db.models import SceneManifest, SceneAudioManifest; print('SceneManifest columns:', [c.name for c in SceneManifest.__table__.columns]); print('SceneAudioManifest columns:', [c.name for c in SceneAudioManifest.__table__.columns]); print('SceneManifest PK:', [c.name for c in SceneManifest.__table__.primary_key.columns]); print('SceneAudioManifest PK:', [c.name for c in SceneAudioManifest.__table__.primary_key.columns])"`
  </verify>
  <done>SceneManifest has columns (project_id, scene_index, manifest_json, composition_shot_type, composition_camera_movement, asset_tags, new_asset_count, created_at) with composite PK (project_id, scene_index). SceneAudioManifest has columns (project_id, scene_index, dialogue_json, sfx_json, ambient_json, music_json, audio_continuity_json, speaker_tags, has_dialogue, has_music, created_at) with composite PK (project_id, scene_index). Both import successfully.</done>
</task>

</tasks>

<verification>
1. All 11 Pydantic schemas import from `vidpipe.schemas.storyboard_enhanced`
2. EnhancedSceneSchema properly inherits SceneSchema fields (scene_index, scene_description, key_details, start_frame_prompt, end_frame_prompt, video_motion_prompt, transition_notes) plus scene_manifest and audio_manifest
3. Both ORM models import from `vidpipe.db.models`
4. Composite primary keys are (project_id, scene_index) on both tables
5. No import errors in existing modules (no circular imports)
</verification>

<success_criteria>
- `from vidpipe.schemas.storyboard_enhanced import EnhancedStoryboardOutput` succeeds
- `from vidpipe.db.models import SceneManifest, SceneAudioManifest` succeeds
- SceneManifest and SceneAudioManifest have correct column types and composite PKs
- EnhancedStoryboardOutput can be used as Gemini response_schema (all fields have Field descriptions)
- No breaking changes to existing storyboard schemas or models
</success_criteria>

<output>
After completion, create `.planning/phases/07-manifest-aware-storyboarding-and-audio-manifest/07-01-SUMMARY.md`
</output>
