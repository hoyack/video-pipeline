---
phase: 03-orchestration-interfaces
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - vidpipe/cli/__init__.py
  - vidpipe/cli/commands.py
  - vidpipe/cli/__main__.py
  - vidpipe/__main__.py
autonomous: true

must_haves:
  truths:
    - "User can generate video from prompt via python -m vidpipe generate 'prompt' with style, aspect-ratio, clip-duration options"
    - "User can resume a failed project via python -m vidpipe resume <project_id>"
    - "User can check project status via python -m vidpipe status <project_id>"
    - "User can list all projects via python -m vidpipe list"
    - "User can re-stitch with crossfade via python -m vidpipe stitch <project_id> --crossfade 0.5"
  artifacts:
    - path: "vidpipe/cli/commands.py"
      provides: "All CLI command handlers using Typer"
      contains: "app = typer.Typer"
      min_lines: 100
    - path: "vidpipe/cli/__main__.py"
      provides: "CLI entry point for python -m vidpipe.cli"
      contains: "app()"
    - path: "vidpipe/__main__.py"
      provides: "Entry point for python -m vidpipe"
      contains: "app()"
  key_links:
    - from: "vidpipe/cli/commands.py"
      to: "vidpipe/orchestrator/pipeline.py"
      via: "import run_pipeline"
      pattern: "from vidpipe\\.orchestrator.* import run_pipeline"
    - from: "vidpipe/cli/commands.py"
      to: "vidpipe/db/__init__.py"
      via: "import init_database and async_session"
      pattern: "from vidpipe\\.db import"
    - from: "vidpipe/cli/commands.py"
      to: "vidpipe/pipeline/stitcher.py"
      via: "import stitch_videos for re-stitch command"
      pattern: "from vidpipe\\.pipeline\\.stitcher import stitch_videos"
---

<objective>
Implement the Typer CLI interface with all 5 commands: generate, resume, status, list, and stitch.

Purpose: The CLI is the primary user interface for the pipeline. Users interact via `python -m vidpipe <command>` to create and manage video generation projects.

Output: `vidpipe/cli/` module with Typer app handling all CLI commands with Rich-formatted output and async database operations.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-orchestration-interfaces/03-RESEARCH.md
@.planning/phases/03-orchestration-interfaces/03-01-SUMMARY.md

@vidpipe/db/models.py
@vidpipe/db/__init__.py
@vidpipe/config.py
@vidpipe/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CLI commands module with all 5 commands</name>
  <files>vidpipe/cli/__init__.py, vidpipe/cli/commands.py</files>
  <action>
Create `vidpipe/cli/__init__.py` as empty init file.

Create `vidpipe/cli/commands.py` implementing all CLI commands using Typer + Rich.

**Setup:**
```python
import asyncio
import uuid
import typer
from rich.console import Console
from rich.table import Table
from sqlalchemy import select, func

from vidpipe import validate_dependencies
from vidpipe.db import init_database, async_session
from vidpipe.db.models import Project, Scene, Keyframe, VideoClip, PipelineRun
from vidpipe.orchestrator.pipeline import run_pipeline
from vidpipe.pipeline.stitcher import stitch_videos

app = typer.Typer(name="vidpipe", help="AI-powered multi-scene video generation pipeline")
console = Console()
```

**Pattern:** Each Typer command is a synchronous function that calls `asyncio.run(_async_impl(...))`. This is the standard pattern for Typer + async (from research Pattern 2).

**Command 1: generate** (CLI-01)
```python
@app.command()
def generate(
    prompt: str = typer.Argument(..., help="Text prompt for video generation"),
    style: str = typer.Option("cinematic", "--style", "-s", help="Visual style"),
    aspect_ratio: str = typer.Option("16:9", "--aspect-ratio", "-a", help="Video aspect ratio"),
    clip_duration: int = typer.Option(5, "--clip-duration", "-d", help="Target clip duration in seconds"),
):
```
- Call `validate_dependencies()` first (fail-fast ffmpeg check)
- Call `init_database()` in async context
- Create Project record with provided options and status="pending"
- Print project ID with Rich
- Use `console.status()` context manager for progress. Pass a `progress_callback` to `run_pipeline` that updates the status spinner message.
- On success: print green checkmark with output path
- On failure: print red X with error, exit code 1
- Print cost warning before starting: "Estimated cost: ~$15 per 5-scene project (Veo video generation)"

**Command 2: resume** (CLI-02)
```python
@app.command()
def resume(
    project_id: str = typer.Argument(..., help="Project UUID to resume"),
):
```
- Parse UUID (catch ValueError for invalid UUIDs)
- Load project from database, error if not found
- Check if project is complete (print message and return if so)
- Check `can_resume(project.status)` from state module
- Use `console.status()` for progress with progress_callback
- Call `run_pipeline(session, project.id, progress_callback=callback)`
- Print success/failure

**Command 3: status** (CLI-03)
```python
@app.command()
def status(
    project_id: str = typer.Argument(..., help="Project UUID"),
):
```
- Load project, show: ID, prompt (truncated to 80 chars), status, style, aspect ratio, created_at, updated_at
- If status is "complete", show output_path
- If status is "failed", show error_message in red
- Query scene count and show it
- Query PipelineRun records and show latest run duration if available
- Use Rich Panel or formatted output (not just print)

**Command 4: list** (CLI-04)
```python
@app.command(name="list")
def list_projects():
```
NOTE: Use `name="list"` to avoid shadowing Python built-in `list`.
- Query all projects ordered by created_at desc
- Display Rich Table with columns: ID (first 8 chars + "..."), Prompt (truncated 50 chars), Status (color-coded: green=complete, red=failed, yellow=in-progress, dim=pending), Created
- If no projects, print "No projects found" in yellow

**Command 5: stitch** (CLI-05)
```python
@app.command()
def stitch(
    project_id: str = typer.Argument(..., help="Project UUID to re-stitch"),
    crossfade: float = typer.Option(0.0, "--crossfade", "-c", help="Crossfade duration in seconds"),
):
```
- Call `validate_dependencies()` (ffmpeg check)
- Load project from database
- Verify project has completed video clips (status should be at least "stitching" or "complete", or has clips in database)
- Temporarily override `settings.pipeline.crossfade_seconds` with the `--crossfade` value if provided
- Call `stitch_videos(session, project)` directly (not full pipeline)
- Update `project.status = "complete"` and `project.output_path` if needed
- Print success with output path

**Important implementation notes:**
- Always call `await init_database()` before any database operations
- Use `async with async_session() as session:` for session management (async_session is an async_sessionmaker, so calling it returns a context manager)
- Color-code status values in output: complete=green, failed=red, storyboarding/keyframing/video_gen/stitching=yellow, pending=dim
- Handle KeyboardInterrupt gracefully in generate/resume commands (print message about resuming later)
  </action>
  <verify>
Run `python -c "from vidpipe.cli.commands import app; print(type(app))"` shows Typer instance. Run `python -m vidpipe --help` shows all 5 commands listed.
  </verify>
  <done>All 5 CLI commands (generate, resume, status, list, stitch) are implemented with Typer decorators, async database operations via asyncio.run(), Rich-formatted output, and proper error handling.</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI and package entry points</name>
  <files>vidpipe/cli/__main__.py, vidpipe/__main__.py</files>
  <action>
Create `vidpipe/cli/__main__.py` as the entry point for `python -m vidpipe.cli`:
```python
"""CLI entry point for python -m vidpipe.cli"""
from vidpipe.cli.commands import app

if __name__ == "__main__":
    app()
```

Create `vidpipe/__main__.py` as the entry point for `python -m vidpipe`:
```python
"""Package entry point for python -m vidpipe"""
from vidpipe.cli.commands import app

if __name__ == "__main__":
    app()
```

Both files simply import and run the Typer app. The `vidpipe/__main__.py` enables `python -m vidpipe generate "prompt"` as the primary CLI invocation pattern per CLI-01.
  </action>
  <verify>
Run `python -m vidpipe --help` shows "AI-powered multi-scene video generation pipeline" with commands: generate, resume, status, list, stitch. Run `python -m vidpipe.cli --help` shows same output.
  </verify>
  <done>Both entry points work: `python -m vidpipe` and `python -m vidpipe.cli` both launch the Typer CLI with all commands accessible.</done>
</task>

</tasks>

<verification>
- `python -m vidpipe --help` shows all 5 commands
- `python -m vidpipe generate --help` shows prompt argument and --style, --aspect-ratio, --clip-duration options
- `python -m vidpipe resume --help` shows project_id argument
- `python -m vidpipe status --help` shows project_id argument
- `python -m vidpipe list --help` works
- `python -m vidpipe stitch --help` shows project_id argument and --crossfade option
</verification>

<success_criteria>
All 5 CLI commands work via `python -m vidpipe <command>`. Generate creates a project and runs the full pipeline with progress display. Resume picks up failed projects. Status shows detailed project info with Rich formatting. List shows all projects in a table. Stitch re-stitches with configurable crossfade. All commands handle errors gracefully with colored output.
</success_criteria>

<output>
After completion, create `.planning/phases/03-orchestration-interfaces/03-02-SUMMARY.md`
</output>
