---
phase: 11-multi-candidate-quality-mode
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - backend/vidpipe/pipeline/video_gen.py
autonomous: true

must_haves:
  truths:
    - "When quality_mode=True, Veo receives number_of_videos=candidate_count in GenerateVideosConfig"
    - "All returned candidates are saved as individual MP4 files and GenerationCandidate records"
    - "CandidateScoringService scores all candidates; highest composite_score is auto-selected"
    - "Selected candidate's local_path is written to VideoClip.local_path so stitcher works unchanged"
    - "Standard mode (quality_mode=False) behavior is completely unchanged — single video path"
    - "RAI filtering with multiple candidates only escalates if ZERO candidates survive"
    - "Post-generation CV analysis runs on the SELECTED candidate only"
  artifacts:
    - path: "backend/vidpipe/pipeline/video_gen.py"
      provides: "Multi-candidate generation flow in _generate_video_for_scene and updated _poll_video_operation"
      contains: "number_of_videos"
  key_links:
    - from: "backend/vidpipe/pipeline/video_gen.py"
      to: "backend/vidpipe/services/candidate_scoring.py"
      via: "CandidateScoringService.score_all_candidates after download"
      pattern: "CandidateScoringService|score_all_candidates"
    - from: "backend/vidpipe/pipeline/video_gen.py"
      to: "backend/vidpipe/db/models.py"
      via: "GenerationCandidate records created per candidate"
      pattern: "GenerationCandidate"
---

<objective>
Wire multi-candidate video generation into the existing video_gen.py pipeline. When quality_mode is enabled, the Veo API generates N candidates per scene, all are saved and scored, and the best candidate is selected — with the stitcher seeing no difference via VideoClip.local_path.

Purpose: This is the core pipeline change that makes Quality Mode functional. Standard mode is untouched.
Output: Modified video_gen.py with multi-candidate flow.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-multi-candidate-quality-mode/11-RESEARCH.md
@.planning/phases/11-multi-candidate-quality-mode/11-01-SUMMARY.md
@backend/vidpipe/pipeline/video_gen.py
@backend/vidpipe/db/models.py
@backend/vidpipe/services/candidate_scoring.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend _submit_video_job with number_of_videos parameter</name>
  <files>backend/vidpipe/pipeline/video_gen.py</files>
  <action>
Modify `_submit_video_job` to accept a `candidate_count` parameter (default 1) and pass it to `GenerateVideosConfig.number_of_videos`:

1. Add `candidate_count: int = 1` parameter to `_submit_video_job` signature.

2. In the GenerateVideosConfig construction, add:
```python
    number_of_videos=candidate_count,
```

3. The rest of _submit_video_job remains unchanged. The API returns a single operation regardless of candidate_count — all candidates are bundled in the response.

This is a minimal, non-breaking change. When candidate_count=1, behavior is identical to current.
  </action>
  <verify>
Inspect the modified _submit_video_job to confirm number_of_videos is passed through. Verify the function signature accepts candidate_count with default=1.
  </verify>
  <done>
_submit_video_job passes number_of_videos to GenerateVideosConfig. Default of 1 preserves standard mode behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Multi-candidate flow in _generate_video_for_scene and updated poll handling</name>
  <files>backend/vidpipe/pipeline/video_gen.py</files>
  <action>
This is the main integration task. Modify `_generate_video_for_scene` and `_poll_video_operation` to handle multi-candidate generation.

**Step A: Add imports at top of video_gen.py:**
```python
from vidpipe.db.models import GenerationCandidate
from vidpipe.services.candidate_scoring import CandidateScoringService
```

Add lazy singleton for scoring service (following existing _cv_analysis_service pattern):
```python
_candidate_scoring_service: CandidateScoringService | None = None

def _get_candidate_scoring_service() -> CandidateScoringService:
    global _candidate_scoring_service
    if _candidate_scoring_service is None:
        _candidate_scoring_service = CandidateScoringService()
    return _candidate_scoring_service
```

**Step B: Modify _poll_video_operation to return all candidates:**

Currently `_poll_video_operation` handles `operation.response.generated_videos[0]` — only the first video. For quality mode, we need ALL videos.

Change the success branch inside _poll_video_operation:

Instead of downloading only `generated_videos[0]`, download ALL generated videos. The function should return the list of video bytes along with the result status.

BUT to minimize changes to the poll function (which is complex and handles crash recovery), use a different approach:

Create a NEW function `_poll_and_collect_candidates` that wraps the poll logic for multi-candidate mode. The existing `_poll_video_operation` continues to work for standard mode (candidate_count=1).

```python
async def _poll_and_collect_candidates(
    session: AsyncSession,
    clip: VideoClip,
    client,
    project: Project,
    scene: Scene,
    file_mgr: FileManager,
    selected_refs: Optional[list] = None,
) -> tuple[str, list[bytes]]:
    """Poll Veo operation and collect ALL candidate video bytes.

    Returns (status, video_bytes_list) where status is one of:
      "complete" — all candidates downloaded
      "content_policy" — filtered by RAI
      "timed_out" — max polls exceeded
      "failed" — non-policy failure

    For content_policy: in Quality Mode, only escalate if ZERO candidates survive.
    Some candidates may be RAI filtered while others succeed.
    """
```

This function follows the same poll loop structure as `_poll_video_operation` but:
- On success: iterates over `operation.response.generated_videos` collecting all video bytes
- On content policy: checks `len(operation.response.generated_videos or [])` — if > 0, returns "complete" with available candidates (partial success). Only returns "content_policy" if ZERO candidates survive.
- Saves the first candidate's data to VideoClip (for backward compat with standard mode logic)

**Step C: Modify _generate_video_for_scene for Quality Mode:**

After the escalation loop's submission and poll sections, add the multi-candidate flow.

The key change is in the escalation loop where poll_result == "complete":

```python
if poll_result == "complete":
    # Quality Mode: save all candidates, score, and select best
    if project.quality_mode and project.candidate_count > 1:
        await _handle_quality_mode_candidates(
            session, scene, project, clip, file_mgr,
            video_bytes_list,  # From _poll_and_collect_candidates
            scene_manifest_row,
            base_video_prompt or scene.video_motion_prompt,
            all_assets if project.manifest_id else [],
        )
    else:
        # Standard Mode: existing behavior (already handled by poll)
        await _run_post_generation_analysis(
            session, scene, clip, project, scene_manifest_row,
        )
    return
```

**Step D: Implement _handle_quality_mode_candidates helper:**

```python
async def _handle_quality_mode_candidates(
    session: AsyncSession,
    scene: Scene,
    project: Project,
    clip: VideoClip,
    file_mgr: FileManager,
    video_bytes_list: list[bytes],
    scene_manifest_row,
    video_prompt: str,
    all_assets: list,
) -> None:
    """Save all candidate videos, score them, and auto-select the best one.

    Steps:
    1. Save each candidate video to disk: tmp/{project_id}/clips/scene_{idx}_candidate_{N}.mp4
    2. Create GenerationCandidate records
    3. Score all candidates via CandidateScoringService
    4. Mark highest composite_score as selected
    5. Update VideoClip.local_path to point to selected candidate
    6. Run CV analysis on selected candidate only
    """
```

Implementation details:

1. For each candidate video bytes:
   - Save to `file_mgr.base_dir / str(project.id) / "clips" / f"scene_{scene.scene_index}_candidate_{i}.mp4"`
   - Create GenerationCandidate record with project_id, scene_index, candidate_number=i, local_path
   - Estimate generation_cost: duration * cost_per_second / candidate_count (split evenly)

2. Get previous scene's selected clip path for continuity scoring:
   ```python
   previous_clip_path = None
   if scene.scene_index > 0:
       # Find the selected candidate (or VideoClip) for the previous scene
       prev_scene_result = await session.execute(
           select(Scene).where(
               Scene.project_id == project.id,
               Scene.scene_index == scene.scene_index - 1
           )
       )
       prev_scene = prev_scene_result.scalar_one_or_none()
       if prev_scene:
           prev_clip_result = await session.execute(
               select(VideoClip).where(VideoClip.scene_id == prev_scene.id)
           )
           prev_clip = prev_clip_result.scalar_one_or_none()
           if prev_clip:
               previous_clip_path = prev_clip.local_path
   ```

3. Score all candidates:
   ```python
   scoring_service = _get_candidate_scoring_service()
   score_results = await scoring_service.score_all_candidates(
       candidates_info=[
           {
               "candidate_video_path": cand.local_path,
               "scene_index": scene.scene_index,
               "scene_manifest_json": scene_manifest_row.manifest_json if scene_manifest_row else None,
               "rewritten_video_prompt": video_prompt,
               "existing_assets": all_assets,
               "previous_scene_clip_path": previous_clip_path,
           }
           for cand in candidate_records
       ]
   )
   ```

4. Update GenerationCandidate records with scores.

5. Select winner (highest composite_score):
   ```python
   winner_idx = max(range(len(score_results)), key=lambda i: score_results[i].get("composite", 0))
   candidate_records[winner_idx].is_selected = True
   candidate_records[winner_idx].selected_by = "auto"
   ```

6. Update VideoClip.local_path to point to winner:
   ```python
   clip.local_path = candidate_records[winner_idx].local_path
   clip.duration_seconds = project.target_clip_duration  # or 8 if refs
   ```

7. Run CV analysis on selected candidate only:
   ```python
   await _run_post_generation_analysis(session, scene, clip, project, scene_manifest_row)
   ```

8. Commit all changes.

**Step E: Update the _submit_video_job call in the escalation loop:**

When calling `_submit_video_job`, pass `candidate_count`:
```python
candidate_count = project.candidate_count if project.quality_mode else 1
operation = await _submit_video_job(
    client, video_model, video_prompt,
    start_frame_bytes, end_frame_bytes, project,
    reference_images=veo_ref_images,
    candidate_count=candidate_count,
)
```

**Step F: Choose poll function based on mode:**

In the escalation loop, use `_poll_and_collect_candidates` when in quality mode, `_poll_video_operation` otherwise. This minimizes changes to existing code paths.

```python
if project.quality_mode and project.candidate_count > 1:
    poll_result, video_bytes_list = await _poll_and_collect_candidates(
        session, clip, client, project, scene, file_mgr, selected_refs,
    )
else:
    poll_result = await _poll_video_operation(
        session, clip, client, project, scene, file_mgr, selected_refs,
    )
    video_bytes_list = []  # Not used in standard mode
```

CRITICAL CONSTRAINTS:
- Standard mode (candidate_count=1) MUST follow the exact same code path as before. Only diverge when quality_mode=True AND candidate_count > 1.
- The stitcher reads VideoClip.local_path — always ensure it points to the selected candidate.
- Scenes are still generated sequentially (scene N uses N-1's selected clip for continuity scoring).
- RAI filtering with multiple candidates: only escalate if ZERO candidates survive. If 2/4 pass, proceed with surviving candidates.
  </action>
  <verify>
1. `python -c "from vidpipe.pipeline.video_gen import generate_videos, _submit_video_job; import inspect; sig = inspect.signature(_submit_video_job); assert 'candidate_count' in sig.parameters; print('OK')"` — confirms parameter added
2. `python -c "from vidpipe.pipeline.video_gen import _handle_quality_mode_candidates, _poll_and_collect_candidates; print('Functions exist')"` — confirms new functions created
3. Verify that the standard mode code path has no new conditional branches (grep for `quality_mode` to confirm it's only checked at the decision points, not scattered throughout)
  </verify>
  <done>
video_gen.py supports multi-candidate generation: _submit_video_job passes number_of_videos, _poll_and_collect_candidates handles multi-video responses, _handle_quality_mode_candidates saves/scores/selects. Standard mode code path unchanged. Selected candidate's path goes to VideoClip.local_path. RAI filtering only escalates on zero survivors.
  </done>
</task>

</tasks>

<verification>
1. Import check: `python -c "from vidpipe.pipeline.video_gen import generate_videos; print('OK')"`
2. Standard mode unchanged: grep video_gen.py for `quality_mode` — should appear only in conditional checks, not in the main standard-mode flow
3. Number_of_videos: grep for `number_of_videos` in video_gen.py — should appear in _submit_video_job's GenerateVideosConfig
4. GenerationCandidate usage: grep for `GenerationCandidate` in video_gen.py — should appear in _handle_quality_mode_candidates
</verification>

<success_criteria>
- _submit_video_job passes number_of_videos=candidate_count to Veo API
- Quality mode: all candidates saved as individual files, scored, best auto-selected
- VideoClip.local_path always points to the selected candidate for stitcher compatibility
- Standard mode (quality_mode=False, candidate_count=1): identical behavior to pre-Phase 11
- RAI filtering: partial success (some candidates survive) treated as success in Quality Mode
- CV analysis runs on selected candidate only (not all candidates)
- Previous scene's selected clip used for continuity scoring
</success_criteria>

<output>
After completion, create `.planning/phases/11-multi-candidate-quality-mode/11-02-SUMMARY.md`
</output>
