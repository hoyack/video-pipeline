---
phase: 12-fork-system-integration-with-manifests
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - frontend/src/api/types.ts
  - frontend/src/api/client.ts
  - frontend/src/components/EditForkPanel.tsx
autonomous: true

must_haves:
  truths:
    - "EditForkPanel shows inherited assets with lock/edit/remove visual controls"
    - "Users can mark assets as removed (struck-through, restorable)"
    - "Users can edit asset reverse_prompt inline"
    - "Users can add new reference images via file picker"
    - "ForkRequest includes asset_changes when submitting fork"
    - "Asset section only appears when project has a manifest"
  artifacts:
    - path: "frontend/src/api/types.ts"
      provides: "TypeScript types for AssetChanges, ModifiedAsset, NewForkUpload, updated ForkRequest and ProjectDetail"
      contains: "AssetChanges"
    - path: "frontend/src/api/client.ts"
      provides: "fetchManifestAssets function for loading assets in EditForkPanel"
      contains: "fetchManifestAssets"
    - path: "frontend/src/components/EditForkPanel.tsx"
      provides: "Asset management section with lock/edit/remove controls and new upload picker"
      contains: "AssetChanges"
  key_links:
    - from: "frontend/src/components/EditForkPanel.tsx"
      to: "frontend/src/api/client.ts"
      via: "Fetches manifest assets on mount using manifest_id from ProjectDetail"
      pattern: "fetchManifestAssets"
    - from: "frontend/src/components/EditForkPanel.tsx"
      to: "frontend/src/api/types.ts"
      via: "Uses AssetChanges, ModifiedAsset, NewForkUpload types for state management"
      pattern: "AssetChanges"
    - from: "frontend/src/components/EditForkPanel.tsx"
      to: "backend/vidpipe/api/routes.py"
      via: "buildForkRequest includes asset_changes in ForkRequest body"
      pattern: "asset_changes"
---

<objective>
Add TypeScript types for asset changes, fetch manifest assets in EditForkPanel, and build the asset management UI with lock/edit/remove controls and new upload capability.

Purpose: This is the user-facing layer that makes fork asset management possible. Without this, users cannot see, modify, or add assets when forking a project.
Output: Updated TypeScript types, API client function, EditForkPanel with full asset section.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-fork-system-integration-with-manifests/12-RESEARCH.md
@.planning/phases/12-fork-system-integration-with-manifests/12-01-SUMMARY.md
@.planning/phases/12-fork-system-integration-with-manifests/12-02-SUMMARY.md

@frontend/src/api/types.ts
@frontend/src/api/client.ts
@frontend/src/components/EditForkPanel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: TypeScript types and API client for asset changes</name>
  <files>frontend/src/api/types.ts, frontend/src/api/client.ts</files>
  <action>
**In `frontend/src/api/types.ts`:**

1. Add `manifest_id` to `ProjectDetail` interface (after `forked_from`):
   ```typescript
   manifest_id?: string | null;
   ```

2. Add three new interfaces BEFORE the existing `ForkRequest` interface:
   ```typescript
   /** Asset modification in a fork */
   export interface ModifiedAsset {
     changes: {
       reverse_prompt?: string;
       name?: string;
       visual_description?: string;
     };
   }

   /** New reference upload to add in fork */
   export interface NewForkUpload {
     image_data: string;  // base64-encoded
     name: string;
     asset_type: string;
     description?: string;
     tags?: string[];
   }

   /** Asset changes for fork request */
   export interface AssetChanges {
     modified_assets?: Record<string, ModifiedAsset>;
     removed_asset_ids?: string[];
     new_uploads?: NewForkUpload[];
   }
   ```

3. Add `asset_changes` to existing `ForkRequest` interface:
   ```typescript
   asset_changes?: AssetChanges;
   ```

**In `frontend/src/api/client.ts`:**

1. Add import for `AssetResponse` type (already exported from types.ts).

2. Add a new function to fetch manifest assets:
   ```typescript
   export async function fetchManifestAssets(manifestId: string): Promise<AssetResponse[]> {
     const res = await fetch(`/api/manifests/${manifestId}`);
     if (!res.ok) throw new ApiError(res.status, await res.text());
     const data = await res.json();
     return data.assets;
   }
   ```
   This reuses the existing `GET /api/manifests/{id}` endpoint which already returns `assets` in its response. No new backend endpoint needed.
  </action>
  <verify>
Run `npx tsc --noEmit` from `frontend/` directory — no type errors.
Grep for AssetChanges in types.ts: must be present.
Grep for fetchManifestAssets in client.ts: must be present.
  </verify>
  <done>TypeScript types for ModifiedAsset, NewForkUpload, AssetChanges exist. ForkRequest includes asset_changes. ProjectDetail includes manifest_id. Client has fetchManifestAssets function.</done>
</task>

<task type="auto">
  <name>Task 2: EditForkPanel asset management section</name>
  <files>frontend/src/components/EditForkPanel.tsx</files>
  <action>
Extend `EditForkPanel.tsx` to add an asset management section that appears when the project has a manifest.

**1. Add imports:**
- `import { useEffect } from "react"` (add to existing React import)
- `import { fetchManifestAssets } from "../api/client.ts"`
- `import type { AssetResponse, AssetChanges, ModifiedAsset, NewForkUpload } from "../api/types.ts"` (extend existing type import)

**2. Add state variables** (after existing state declarations, around line 46):
```typescript
// Asset management state (Phase 12)
const [assets, setAssets] = useState<AssetResponse[]>([]);
const [assetsLoading, setAssetsLoading] = useState(false);
const [modifiedAssets, setModifiedAssets] = useState<Record<string, ModifiedAsset>>({});
const [removedAssetIds, setRemovedAssetIds] = useState<Set<string>>(new Set());
const [newUploads, setNewUploads] = useState<NewForkUpload[]>([]);
```

**3. Add useEffect** to fetch assets on mount when manifest_id exists:
```typescript
useEffect(() => {
  if (!detail.manifest_id) return;
  setAssetsLoading(true);
  fetchManifestAssets(detail.manifest_id)
    .then(setAssets)
    .catch(() => {}) // Silent fail — asset section just won't show
    .finally(() => setAssetsLoading(false));
}, [detail.manifest_id]);
```

**4. Add helper functions:**

```typescript
function getAssetStatus(assetId: string): "locked" | "modified" | "removed" {
  if (removedAssetIds.has(assetId)) return "removed";
  if (modifiedAssets[assetId]) return "modified";
  return "locked";
}

function handleRemoveAsset(assetId: string) {
  setRemovedAssetIds((prev) => new Set(prev).add(assetId));
}

function handleRestoreAsset(assetId: string) {
  setRemovedAssetIds((prev) => {
    const next = new Set(prev);
    next.delete(assetId);
    return next;
  });
  // Also clear any modifications
  setModifiedAssets((prev) => {
    const next = { ...prev };
    delete next[assetId];
    return next;
  });
}

function handleEditAssetField(assetId: string, field: string, value: string) {
  const asset = assets.find((a) => a.asset_id === assetId);
  if (!asset) return;
  const original = field === "reverse_prompt" ? asset.reverse_prompt ?? "" : asset.name;
  setModifiedAssets((prev) => {
    const existing = prev[assetId]?.changes || {};
    const updated = { ...existing, [field]: value };
    // Remove field if back to original
    if (value === original) delete updated[field];
    if (Object.keys(updated).length === 0) {
      const next = { ...prev };
      delete next[assetId];
      return next;
    }
    return { ...prev, [assetId]: { changes: updated } };
  });
}

function handleAddUpload(files: FileList | null) {
  if (!files) return;
  Array.from(files).forEach((file) => {
    const reader = new FileReader();
    reader.onload = () => {
      const base64 = (reader.result as string).split(",")[1]; // strip data:...;base64, prefix
      setNewUploads((prev) => [
        ...prev,
        {
          image_data: base64,
          name: file.name.replace(/\.[^.]+$/, ""),
          asset_type: "CHARACTER",
          description: undefined,
          tags: undefined,
        },
      ]);
    };
    reader.readAsDataURL(file);
  });
}

function handleRemoveUpload(index: number) {
  setNewUploads((prev) => prev.filter((_, i) => i !== index));
}
```

**5. Update `buildForkRequest`:**
At the end of the existing function (before `return req;`), add:
```typescript
if (detail.manifest_id && (Object.keys(modifiedAssets).length > 0 || removedAssetIds.size > 0 || newUploads.length > 0)) {
  req.asset_changes = {
    modified_assets: Object.keys(modifiedAssets).length > 0 ? modifiedAssets : undefined,
    removed_asset_ids: removedAssetIds.size > 0 ? [...removedAssetIds] : undefined,
    new_uploads: newUploads.length > 0 ? newUploads : undefined,
  };
}
```

**6. Update `hasChanges`** to also consider asset changes:
```typescript
const hasChanges = () => {
  const req = buildForkRequest();
  return Object.keys(req).length > 0;
};
```
This already works because asset_changes gets added to the request object.

**7. Add asset section JSX** — insert BEFORE the "Scene Edits" section (before `{detail.scenes.length > 0 && (`). Only render when manifest_id exists:

```tsx
{/* Asset Registry (Phase 12) */}
{detail.manifest_id && (
  <div>
    <h3 className="mb-3 text-sm font-medium text-gray-400">
      Asset Registry
      {assets.length > 0 && (
        <span className="ml-2 text-gray-500">
          ({assets.length - removedAssetIds.size} active
          {removedAssetIds.size > 0 && `, ${removedAssetIds.size} removed`}
          {newUploads.length > 0 && `, ${newUploads.length} new`})
        </span>
      )}
    </h3>

    {assetsLoading ? (
      <div className="text-sm text-gray-500">Loading assets...</div>
    ) : assets.length === 0 ? (
      <div className="text-sm text-gray-500">No assets in manifest</div>
    ) : (
      <div className="space-y-2 max-h-80 overflow-y-auto">
        {assets.map((asset) => {
          const status = getAssetStatus(asset.asset_id);
          return (
            <div
              key={asset.asset_id}
              className={clsx(
                "flex items-center gap-3 rounded-lg border px-3 py-2",
                status === "removed"
                  ? "border-red-800/50 bg-red-900/20 opacity-60"
                  : status === "modified"
                  ? "border-amber-700 bg-amber-900/20"
                  : "border-gray-700 bg-gray-900",
              )}
            >
              {/* Thumbnail */}
              {asset.thumbnail_url || asset.reference_image_url ? (
                <img
                  src={asset.thumbnail_url || asset.reference_image_url || ""}
                  alt={asset.name}
                  className="h-10 w-10 rounded object-cover"
                />
              ) : (
                <div className="flex h-10 w-10 items-center justify-center rounded bg-gray-800 text-xs text-gray-500">
                  {asset.manifest_tag}
                </div>
              )}

              {/* Info */}
              <div className="min-w-0 flex-1">
                <div className={clsx("text-sm font-medium", status === "removed" ? "text-gray-500 line-through" : "text-gray-200")}>
                  {asset.manifest_tag} — {asset.name}
                </div>
                {status !== "removed" && (
                  <input
                    type="text"
                    value={modifiedAssets[asset.asset_id]?.changes?.reverse_prompt ?? asset.reverse_prompt ?? ""}
                    onChange={(e) => handleEditAssetField(asset.asset_id, "reverse_prompt", e.target.value)}
                    placeholder="Reverse prompt..."
                    className={clsx(
                      "mt-1 w-full rounded border bg-transparent px-2 py-0.5 text-xs text-gray-400 focus:outline-none focus:ring-1",
                      status === "modified" ? "border-amber-700 focus:ring-amber-500" : "border-gray-700 focus:ring-blue-500",
                    )}
                  />
                )}
              </div>

              {/* Status badge */}
              <span className={clsx(
                "shrink-0 rounded px-1.5 py-0.5 text-xs font-medium",
                status === "locked" && "bg-gray-800 text-gray-400",
                status === "modified" && "bg-amber-900/50 text-amber-300",
                status === "removed" && "bg-red-900/50 text-red-400",
              )}>
                {status === "locked" ? "Inherited" : status === "modified" ? "Edited" : "Removed"}
              </span>

              {/* Actions */}
              <div className="flex shrink-0 gap-1">
                {status === "removed" ? (
                  <button
                    onClick={() => handleRestoreAsset(asset.asset_id)}
                    className="rounded px-2 py-1 text-xs text-blue-400 hover:bg-blue-900/30"
                    title="Restore"
                  >
                    Restore
                  </button>
                ) : (
                  <button
                    onClick={() => handleRemoveAsset(asset.asset_id)}
                    className="rounded px-2 py-1 text-xs text-red-400 hover:bg-red-900/30"
                    title="Remove from fork"
                  >
                    Remove
                  </button>
                )}
              </div>
            </div>
          );
        })}
      </div>
    )}

    {/* New Uploads */}
    {newUploads.length > 0 && (
      <div className="mt-3 space-y-2">
        <div className="text-xs font-medium text-green-400">New Uploads</div>
        {newUploads.map((upload, i) => (
          <div key={i} className="flex items-center gap-2 rounded-lg border border-green-800/50 bg-green-900/20 px-3 py-2">
            <div className="text-sm text-gray-300">{upload.name}</div>
            <span className="text-xs text-gray-500">{upload.asset_type}</span>
            <div className="flex-1" />
            <button
              onClick={() => handleRemoveUpload(i)}
              className="rounded px-2 py-1 text-xs text-red-400 hover:bg-red-900/30"
            >
              Remove
            </button>
          </div>
        ))}
      </div>
    )}

    {/* Add New button */}
    <label className="mt-3 flex cursor-pointer items-center gap-2 rounded-lg border border-dashed border-gray-700 px-3 py-2 text-sm text-gray-400 hover:border-gray-600 hover:text-gray-300 transition-colors">
      <span>+ Add New Reference Images</span>
      <input
        type="file"
        accept="image/*"
        multiple
        className="hidden"
        onChange={(e) => handleAddUpload(e.target.files)}
      />
    </label>
  </div>
)}
```

The asset section uses:
- Dark theme consistent with existing EditForkPanel (gray-900 bg, gray-700 borders)
- Amber highlight for modified assets (matches existing "changed" pattern for prompt textarea)
- Red for removed with line-through text
- Green for new uploads
- Inline reverse_prompt editing (input field per asset)
- File picker for new uploads with base64 encoding
- Max height with scroll for large asset lists (max-h-80 overflow-y-auto)
  </action>
  <verify>
Run `npx tsc --noEmit` from `frontend/` directory — no type errors.
Run `npx vite build` from `frontend/` directory — builds without errors.
  </verify>
  <done>EditForkPanel shows inherited assets with lock/edit/remove controls, inline reverse_prompt editing, new upload file picker, and includes asset_changes in fork request submission.</done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` — zero type errors
2. `cd frontend && npx vite build` — builds successfully
3. `grep -n "AssetChanges" frontend/src/api/types.ts` — interface exists
4. `grep -n "manifest_id" frontend/src/api/types.ts` — present in ProjectDetail
5. `grep -n "asset_changes" frontend/src/components/EditForkPanel.tsx` — present in buildForkRequest
6. `grep -n "fetchManifestAssets" frontend/src/api/client.ts` — function exists
7. `grep -n "Asset Registry" frontend/src/components/EditForkPanel.tsx` — section header present
</verification>

<success_criteria>
- TypeScript types for ModifiedAsset, NewForkUpload, AssetChanges defined
- ProjectDetail has manifest_id field
- ForkRequest has asset_changes field
- fetchManifestAssets client function exists
- EditForkPanel fetches and displays manifest assets when manifest_id exists
- Each asset shows inherited/edited/removed status with appropriate styling
- Reverse prompt editable inline per asset
- Remove button marks assets for exclusion (restorable)
- File picker adds new reference images as base64 NewForkUpload entries
- buildForkRequest includes asset_changes when changes exist
- Frontend builds without type errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-fork-system-integration-with-manifests/12-03-SUMMARY.md`
</output>
