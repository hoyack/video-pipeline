---
phase: 03-orchestration-interfaces
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - vidpipe/api/__init__.py
  - vidpipe/api/app.py
  - vidpipe/api/routes.py
  - vidpipe/api/__main__.py
autonomous: true

must_haves:
  truths:
    - "POST /api/generate starts pipeline in background and returns project_id with 202 status"
    - "GET /api/projects/{id}/status returns lightweight status for polling"
    - "GET /api/projects/{id} returns full project detail with scenes and clips"
    - "GET /api/projects lists all projects"
    - "POST /api/projects/{id}/resume resumes a failed pipeline in background"
    - "GET /api/projects/{id}/download serves final MP4 file"
    - "GET /api/health returns health check"
  artifacts:
    - path: "vidpipe/api/app.py"
      provides: "FastAPI application instance with lifespan and exception handlers"
      contains: "app = FastAPI"
      min_lines: 30
    - path: "vidpipe/api/routes.py"
      provides: "All 7 API endpoint handlers"
      min_lines: 120
    - path: "vidpipe/api/__main__.py"
      provides: "API server entry point for python -m vidpipe.api"
      contains: "uvicorn.run"
  key_links:
    - from: "vidpipe/api/routes.py"
      to: "vidpipe/orchestrator/pipeline.py"
      via: "import run_pipeline for background tasks"
      pattern: "from vidpipe\\.orchestrator.* import run_pipeline"
    - from: "vidpipe/api/routes.py"
      to: "vidpipe/db/__init__.py"
      via: "import async_session for database operations"
      pattern: "from vidpipe\\.db import"
    - from: "vidpipe/api/app.py"
      to: "vidpipe/api/routes.py"
      via: "include router"
      pattern: "app\\.include_router"
---

<objective>
Implement the FastAPI HTTP API with all 7 endpoints: generate, status, project detail, project list, resume, download, and health check.

Purpose: The HTTP API enables programmatic access and automation of the video pipeline. It uses BackgroundTasks for async pipeline execution and follows the async request-reply pattern with status polling.

Output: `vidpipe/api/` module with FastAPI app serving all endpoints, Pydantic response schemas, and background task execution.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-orchestration-interfaces/03-RESEARCH.md
@.planning/phases/03-orchestration-interfaces/03-01-SUMMARY.md

@vidpipe/db/models.py
@vidpipe/db/__init__.py
@vidpipe/db/engine.py
@vidpipe/config.py
@vidpipe/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FastAPI app with Pydantic schemas and all 7 route handlers</name>
  <files>vidpipe/api/__init__.py, vidpipe/api/app.py, vidpipe/api/routes.py</files>
  <action>
Create `vidpipe/api/__init__.py` as empty init file.

**Create `vidpipe/api/app.py`** with FastAPI application setup:

1. Create FastAPI instance with title="Video Pipeline API", version="0.1.0"
2. Use `@asynccontextmanager` lifespan (NOT deprecated `on_event`) to:
   - On startup: call `validate_dependencies()` and `await init_database()`
   - On shutdown: call `await shutdown()` from db module
3. Include router from routes module: `app.include_router(router)`
4. Add generic exception handler that returns 500 with error message (prevents stack traces in API responses)

**Create `vidpipe/api/routes.py`** with all endpoint handlers:

**Pydantic response schemas** (define at top of routes.py):
- `GenerateRequest(BaseModel)`: prompt (str), style (str, default "cinematic"), aspect_ratio (str, default "16:9"), clip_duration (int, default 5)
- `GenerateResponse(BaseModel)`: project_id (str), status (str), status_url (str)
- `StatusResponse(BaseModel)`: project_id (str), status (str), created_at (str), updated_at (str), error_message (Optional[str])
- `SceneDetail(BaseModel)`: scene_index (int), description (str), status (str), has_start_keyframe (bool), has_end_keyframe (bool), has_clip (bool), clip_status (Optional[str])
- `ProjectDetail(BaseModel)`: project_id (str), prompt (str), style (str), aspect_ratio (str), status (str), created_at (str), updated_at (str), scene_count (int), scenes (list[SceneDetail]), error_message (Optional[str])
- `ProjectListItem(BaseModel)`: project_id (str), prompt (str), status (str), created_at (str)
- `ResumeResponse(BaseModel)`: project_id (str), status (str), status_url (str)

**Background task wrapper:**
```python
async def run_pipeline_background(project_id: uuid.UUID):
    """Run pipeline in background with fresh session (never share session across async boundaries)."""
    async with async_session() as session:
        try:
            await run_pipeline(session, project_id)
        except Exception:
            # Error already persisted to database by orchestrator
            pass
```
CRITICAL: Create fresh session inside background task. Never pass session from request handler to background task (research Pitfall 2).

**Endpoint 1: POST /api/generate** (API-01)
- Accept `GenerateRequest` body
- Create Project record with provided options, status="pending"
- Commit and capture project_id BEFORE adding background task
- Add `run_pipeline_background(project_id)` to BackgroundTasks
- Return 202 with `GenerateResponse` including status_url

**Endpoint 2: GET /api/projects/{project_id}/status** (API-02)
- Load project by UUID, 404 if not found
- Return `StatusResponse` with project-level status only (lightweight for polling)
- Do NOT include scene details (that's the detail endpoint)

**Endpoint 3: GET /api/projects/{project_id}** (API-03)
- Load project by UUID, 404 if not found
- Query scenes with their keyframes and clips
- Build `SceneDetail` list with keyframe/clip existence flags
- Return `ProjectDetail` with full scene breakdown

**Endpoint 4: GET /api/projects** (API-04)
- Query all projects ordered by created_at desc
- Return `list[ProjectListItem]`

**Endpoint 5: POST /api/projects/{project_id}/resume** (API-05)
- Load project, 404 if not found
- Check `can_resume(project.status)` from state module, return 409 if not resumable (including "complete")
- Add `run_pipeline_background(project_id)` to BackgroundTasks
- Return 202 with `ResumeResponse`

**Endpoint 6: GET /api/projects/{project_id}/download** (API-06)
- Load project, 404 if not found
- Check status == "complete", return 409 if not ready
- Check `project.output_path` exists and file exists on disk, 404 if not
- Return `FileResponse` with media_type="video/mp4" and Content-Disposition attachment header
- Filename: `video_{project_id}.mp4`

**Endpoint 7: GET /api/health** (API-07)
- Return `{"status": "ok", "version": "0.1.0"}`

**Important implementation notes:**
- Use `APIRouter` in routes.py, include it in app.py. This keeps app creation and routes separate.
- All database operations use `async with async_session() as session:` (NOT the `get_session` generator, which is designed for FastAPI Depends but we keep it simpler with direct session usage)
- Parse project_id as `uuid.UUID` in path parameter type hint â€” FastAPI validates automatically
- Do NOT expose internal file paths in responses (research Pitfall 7). output_path only used internally for download endpoint.
- Use `from vidpipe.orchestrator.state import can_resume` for resume validation
  </action>
  <verify>
Run `python -c "from vidpipe.api.app import app; print(app.title)"` shows "Video Pipeline API". Run `python -c "from vidpipe.api.routes import router; print(len(router.routes))"` shows 7 routes.
  </verify>
  <done>FastAPI app created with 7 endpoints, Pydantic response schemas exclude internal fields, background tasks create fresh sessions, generate/resume return 202 with status URL, download serves MP4 via FileResponse.</done>
</task>

<task type="auto">
  <name>Task 2: Create API server entry point</name>
  <files>vidpipe/api/__main__.py</files>
  <action>
Create `vidpipe/api/__main__.py` as the entry point for `python -m vidpipe.api`:

```python
"""API server entry point for python -m vidpipe.api"""
import uvicorn
from vidpipe.config import settings

if __name__ == "__main__":
    uvicorn.run(
        "vidpipe.api.app:app",
        host=settings.server.host,
        port=settings.server.port,
        reload=False,
    )
```

Use `settings.server.host` and `settings.server.port` from config (already defined in ServerConfig model). Use string import path "vidpipe.api.app:app" for uvicorn (not direct app reference) to support potential reload mode in development.
  </action>
  <verify>
Run `python -c "import vidpipe.api.__main__"` imports without error (won't start server since __name__ != "__main__").
  </verify>
  <done>API server can be started via `python -m vidpipe.api` using configured host/port from settings.</done>
</task>

</tasks>

<verification>
- `python -c "from vidpipe.api.app import app; print(app.title)"` shows "Video Pipeline API"
- `python -c "from vidpipe.api.routes import router; print([r.path for r in router.routes])"` lists all 7 endpoint paths
- Response schemas do not include output_path or any internal file paths
- Background task wrapper creates fresh session (not sharing request session)
- Generate and resume endpoints return 202 status code
- Health endpoint returns {"status": "ok"}
</verification>

<success_criteria>
All 7 API endpoints implemented. Generate and resume return 202 with background task execution. Status endpoint is lightweight for polling. Detail endpoint includes scene-level breakdown. Download serves MP4 files. All responses use Pydantic schemas that exclude internal implementation details. Server starts via `python -m vidpipe.api` with configured host/port.
</success_criteria>

<output>
After completion, create `.planning/phases/03-orchestration-interfaces/03-03-SUMMARY.md`
</output>
