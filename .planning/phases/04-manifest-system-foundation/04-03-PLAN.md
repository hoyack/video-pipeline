---
phase: 04-manifest-system-foundation
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - frontend/src/components/ManifestCreator.tsx
  - frontend/src/components/AssetUploader.tsx
  - frontend/src/components/AssetEditor.tsx
  - frontend/src/api/client.ts
  - frontend/src/App.tsx
autonomous: false

must_haves:
  truths:
    - "User can create a new manifest with name, description, and category"
    - "User can drag-drop or click-to-select multiple images for upload"
    - "Each uploaded image becomes an asset with editable name, type, description, and tags"
    - "User can see all uploaded assets in a visual list with image thumbnails"
    - "User can edit asset metadata (name, type, description, tags) inline"
    - "User can remove individual assets"
    - "User can save the manifest as DRAFT status"
    - "Manifest tag (CHAR_01, OBJ_02) is auto-assigned based on asset type"
  artifacts:
    - path: "frontend/src/components/ManifestCreator.tsx"
      provides: "Stage 1 manifest creation workflow with header form and asset list"
      contains: "ManifestCreator"
    - path: "frontend/src/components/AssetUploader.tsx"
      provides: "Drag-drop multi-file image upload zone"
      contains: "AssetUploader"
    - path: "frontend/src/components/AssetEditor.tsx"
      provides: "Inline asset metadata editor with thumbnail, name, type, description, tags"
      contains: "AssetEditor"
  key_links:
    - from: "frontend/src/components/ManifestCreator.tsx"
      to: "frontend/src/api/client.ts"
      via: "createManifest, createAsset, uploadAssetImage calls"
      pattern: "createManifest|createAsset|uploadAssetImage"
    - from: "frontend/src/components/AssetUploader.tsx"
      to: "frontend/src/components/ManifestCreator.tsx"
      via: "onFilesSelected callback with File[]"
      pattern: "onFilesSelected"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/ManifestCreator.tsx"
      via: "conditional rendering when currentView is manifest-creator"
      pattern: "ManifestCreator"
---

<objective>
Build the Manifest Creator Stage 1 UI: a form where users can create a new manifest, drag-drop upload images, tag each image as an asset with name/type/description/tags, and save the manifest as DRAFT.

Purpose: Gives users a dedicated workspace for building manifests by uploading reference images and adding metadata. This is the "pre-production" step before any AI processing (Stages 2-3 in Phase 5).

Output: ManifestCreator.tsx (main workflow), AssetUploader.tsx (drag-drop zone), AssetEditor.tsx (per-asset inline editor), updated API client with upload function, and App.tsx integration.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-manifest-system-foundation/04-RESEARCH.md
@.planning/phases/04-manifest-system-foundation/04-01-SUMMARY.md
@frontend/src/App.tsx
@frontend/src/api/client.ts
@frontend/src/api/types.ts
@frontend/src/components/GenerateForm.tsx
@frontend/src/components/StatusBadge.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: AssetUploader drag-drop component and AssetEditor inline editor</name>
  <files>
    frontend/src/components/AssetUploader.tsx
    frontend/src/components/AssetEditor.tsx
    frontend/src/api/client.ts
  </files>
  <action>
**Add to `frontend/src/api/client.ts`** — asset CRUD and upload functions:

```typescript
/** POST /api/manifests/{id}/assets — create asset in manifest */
export function createAsset(manifestId: string, body: CreateAssetRequest): Promise<AssetResponse> {
  return request<AssetResponse>(`/api/manifests/${manifestId}/assets`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
}

/** PUT /api/assets/{id} — update asset metadata */
export function updateAsset(assetId: string, body: UpdateAssetRequest): Promise<AssetResponse> {
  return request<AssetResponse>(`/api/assets/${assetId}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
}

/** DELETE /api/assets/{id} — delete asset */
export function deleteAsset(assetId: string): Promise<{ status: string; asset_id: string }> {
  return request<{ status: string; asset_id: string }>(`/api/assets/${assetId}`, {
    method: "DELETE",
  });
}

/** POST /api/assets/{id}/upload — upload image for asset */
export async function uploadAssetImage(assetId: string, file: File): Promise<AssetResponse> {
  const formData = new FormData();
  formData.append("file", file);
  const res = await fetch(`/api/assets/${assetId}/upload`, {
    method: "POST",
    body: formData,
  });
  if (!res.ok) {
    const body = await res.json().catch(() => ({ detail: res.statusText }));
    throw new ApiError(res.status, body.detail ?? res.statusText);
  }
  return res.json() as Promise<AssetResponse>;
}
```

Import `UpdateAssetRequest`, `CreateAssetRequest`, and `AssetResponse` from types.ts (add to existing import statement).

**Create `frontend/src/components/AssetUploader.tsx`** — drag-drop upload zone:

Use native HTML5 drag-drop events (no external library per research "Don't Hand-Roll" recommendation of HTML5 native for simple cases). The research also suggests react-dropzone as alternative, but HTML5 native is sufficient for Stage 1.

Props:
```typescript
interface AssetUploaderProps {
  onFilesSelected: (files: File[]) => void;
  disabled?: boolean;
}
```

Behavior:
- Accept image/png, image/jpeg, image/webp files only
- Filter out non-image files silently
- Support multiple files at once (both drag-drop and click-to-select)
- Max 10MB per file — show brief inline error for files exceeding limit
- Track drag state for visual feedback (isDragging boolean)

Layout:
- Container: `rounded-lg border-2 border-dashed border-gray-700 p-8 text-center transition-colors` + when dragging: `border-blue-500 bg-blue-500/5`
- Icon area: Upload cloud icon (use a simple SVG inline or unicode arrow up character)
- Primary text: "Drag and drop images here" (text-gray-300)
- Secondary text: "or click to browse" (text-sm text-gray-500)
- Supported formats note: "PNG, JPEG, WebP up to 10MB each" (text-xs text-gray-600)
- Hidden `<input type="file" multiple accept="image/png,image/jpeg,image/webp">` triggered by clicking the zone

Events:
- `onDragOver`: e.preventDefault(), set isDragging=true
- `onDragLeave`: set isDragging=false
- `onDrop`: e.preventDefault(), extract files from e.dataTransfer.files, filter by type and size, call onFilesSelected
- Hidden input `onChange`: extract files, filter, call onFilesSelected
- When disabled, show reduced opacity and ignore events

**Create `frontend/src/components/AssetEditor.tsx`** — inline editor for a single asset:

Props:
```typescript
interface AssetEditorProps {
  asset: AssetResponse;
  imageFile?: File;  // Local file reference for thumbnail preview (before upload completes)
  onUpdate: (assetId: string, updates: UpdateAssetRequest) => void;
  onDelete: (assetId: string) => void;
  isUploading?: boolean;
}
```

Layout (horizontal card, flex row):
1. **Thumbnail** (left, w-24 h-24 flex-shrink-0):
   - If `imageFile` exists: show local preview via `URL.createObjectURL(imageFile)` (revoke on cleanup via useEffect)
   - Else if `asset.reference_image_url` exists: show `<img src={asset.reference_image_url}>` (won't work directly for local paths; show a placeholder icon instead — the actual image serving endpoint can be added later)
   - Else: gray placeholder with image icon
   - Rounded corners, object-cover

2. **Metadata fields** (middle, flex-1, flex-col gap-2):
   - **Name**: `<input>` text field, value=asset.name, onBlur calls onUpdate. Style: `bg-transparent border-b border-gray-700 text-gray-200 text-sm w-full focus:border-blue-500 outline-none`
   - **Type dropdown**: `<select>` with options: CHARACTER, OBJECT, ENVIRONMENT, PROP, STYLE, OTHER. onChange calls onUpdate. Style same as sort dropdown.
   - **Description**: `<textarea>` 2 rows, optional. onBlur calls onUpdate. Same transparent border-b style.
   - **Tags**: Simple text input where user types comma-separated tags. Parse on blur, call onUpdate with `user_tags: value.split(",").map(t => t.trim()).filter(Boolean)`. Show existing tags as small pills above input.

3. **Right side** (flex-shrink-0, flex-col items-end gap-2):
   - **Manifest tag badge**: Show `asset.manifest_tag` in a pill (text-xs font-mono bg-gray-800 rounded px-2 py-0.5 text-gray-400)
   - **Upload status**: If isUploading, show a small spinner or "Uploading..." text
   - **Delete button**: Red X icon or "Remove" text (text-sm text-red-400 hover:text-red-300), onClick calls onDelete with confirmation

Use debounced updates: Don't call onUpdate on every keystroke, only on blur. This prevents excessive API calls.

Container: `rounded-lg border border-gray-800 bg-gray-900/30 p-3 flex items-start gap-4`
  </action>
  <verify>
Run `cd /home/ubuntu/work/video-pipeline/frontend && npx tsc --noEmit` to verify TypeScript compilation succeeds with zero errors. Verify AssetUploader.tsx, AssetEditor.tsx, and updated client.ts all compile.
  </verify>
  <done>
AssetUploader renders a drag-drop zone accepting PNG/JPEG/WebP images up to 10MB with visual drag feedback. AssetEditor renders inline metadata editing (name, type, description, tags) with image thumbnail and manifest tag badge. API client has 4 new functions (createAsset, updateAsset, deleteAsset, uploadAssetImage). All TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: ManifestCreator workflow view and App.tsx integration</name>
  <files>
    frontend/src/components/ManifestCreator.tsx
    frontend/src/App.tsx
  </files>
  <action>
**Create `frontend/src/components/ManifestCreator.tsx`** — Stage 1 manifest creation workflow:

Props:
```typescript
interface ManifestCreatorProps {
  manifestId?: string | null;  // null = create new, string = edit existing
  onSaved: (manifestId: string) => void;
  onCancel: () => void;
}
```

State:
- `manifest: ManifestListItem | null` — loaded manifest (when editing)
- `assets: AssetResponse[]` — current assets list
- `pendingFiles: Map<string, File>` — assetId -> File mapping for local previews
- `name: string` — manifest name input
- `description: string` — manifest description input
- `category: string` — selected category (default "CUSTOM")
- `tags: string` — comma-separated tags input
- `saving: boolean` — save operation in progress
- `error: string | null` — error message
- `isNewManifest: boolean` — true when creating (no manifestId prop)

Workflow:

**Create mode** (manifestId is null):
1. User fills in name (required), description, category, tags in the header form
2. User drags/drops images into the upload zone
3. For each dropped file:
   a. Call `createManifest()` first if manifest hasn't been created yet (lazy creation — create on first upload, not on form load). Use name from input (default "Untitled Manifest" if empty). Store returned manifest_id.
   b. Call `createAsset(manifestId, { name: filename_without_extension, asset_type: "CHARACTER" })` — default type is CHARACTER, user can change
   c. Call `uploadAssetImage(assetId, file)` to upload the image
   d. Add asset to local state, store file in pendingFiles for preview
   e. Process files sequentially (one at a time) to avoid overwhelming the API
4. User edits asset metadata inline via AssetEditor components
5. User clicks "Save Draft" to finalize — calls `updateManifest()` with current name/description/category/tags

**Edit mode** (manifestId is provided):
1. Load manifest detail via `getManifestDetail(manifestId)` on mount
2. Populate form fields from manifest data
3. Show existing assets with AssetEditor
4. User can add more images, edit metadata, delete assets
5. "Save" updates manifest metadata

Layout (vertical):
1. **Back link** (mb-6): `<button className="text-sm text-gray-400 hover:text-gray-300">← Back to Library</button>` — calls onCancel

2. **Header form** (mb-8, rounded-lg border border-gray-800 bg-gray-900/50 p-6):
   - Title: "New Manifest" or "Edit Manifest" (text-xl font-bold text-white mb-4)
   - **Name input**: Full width, required. Label "Name" (text-sm text-gray-400 mb-1). Input: `bg-gray-900 border border-gray-700 rounded-lg px-3 py-2 text-gray-200 w-full focus:border-blue-500 outline-none`
   - **Description textarea**: Full width, 3 rows. Same styling.
   - **Category + Tags row** (flex gap-4 mt-4):
     - Category: `<select>` with 6 options. Same styling as other selects.
     - Tags: Text input, comma-separated. Same styling.

3. **Upload zone** (mb-8): Render AssetUploader component. Pass `onFilesSelected` handler.

4. **Asset list** (mb-8):
   - Section header: "Assets ({count})" (text-lg font-medium text-gray-200 mb-4)
   - If no assets: "No assets yet. Drop images above to add assets." (text-sm text-gray-500 text-center py-8)
   - Map over assets, render AssetEditor for each. Pass pendingFiles.get(asset.asset_id) as imageFile prop.
   - Flex column with gap-3

5. **Footer actions** (flex justify-end gap-3 pt-6 border-t border-gray-800):
   - "Cancel" button: `text-gray-400 hover:text-gray-300 px-4 py-2 text-sm` — calls onCancel
   - "Save Draft" button: `bg-blue-600 hover:bg-blue-500 text-white rounded-lg px-6 py-2 text-sm font-medium disabled:opacity-50` — disabled when saving or name is empty

Error handling:
- Show error banner at top if any operation fails (red bg, white text, dismiss button)
- Individual asset upload failures show error state on that specific AssetEditor

**Update `frontend/src/App.tsx`**:
- Import ManifestCreator: `import { ManifestCreator } from "./components/ManifestCreator.tsx";`
- Replace the placeholder manifest-creator block with the real component:
  ```tsx
  {currentView === "manifest-creator" && (
    <ManifestCreator
      manifestId={activeManifestId}
      onSaved={(id) => {
        setActiveManifestId(null);
        navigateTo("manifests");
      }}
      onCancel={() => {
        setActiveManifestId(null);
        navigateTo("manifests");
      }}
    />
  )}
  ```
- When navigating to create new manifest (from Library's "+ New Manifest"), set `activeManifestId` to null before navigating
- When navigating to edit (from Library's edit action), set `activeManifestId` to the manifest ID
  </action>
  <verify>
1. Run `cd /home/ubuntu/work/video-pipeline/frontend && npx tsc --noEmit` — zero errors.
2. Run `cd /home/ubuntu/work/video-pipeline/frontend && npm run build` — build succeeds.
3. Manual test with backend running:
   a. Navigate to Manifests → Click "+ New Manifest"
   b. Enter a name and description
   c. Drag-drop 2-3 images into the upload zone
   d. Verify assets appear with thumbnails (local preview) and editable fields
   e. Change asset type dropdown — verify manifest_tag updates after save
   f. Click "Save Draft" — verify redirect to library with new manifest visible
   g. Click "Edit" on the manifest — verify creator loads with existing data
  </verify>
  <done>
ManifestCreator supports Stage 1 workflow: create/edit manifest metadata, drag-drop image upload, per-asset inline editing (name, type, description, tags), auto-generated manifest tags, and save as DRAFT. Lazy manifest creation on first upload. Edit mode loads existing manifest data. App.tsx routes to creator from library. All TypeScript compiles and builds cleanly.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Manifest System Foundation: backend database + API (Plan 01) and frontend Manifest Library + Creator Stage 1 (Plans 02-03). Users can create manifests, upload reference images, tag assets, browse the library with filters/sort, and perform CRUD actions.</what-built>
  <how-to-verify>
1. Start backend: `cd /home/ubuntu/work/video-pipeline && python -m vidpipe.api`
2. Start frontend: `cd /home/ubuntu/work/video-pipeline/frontend && npm run dev`
3. Open http://localhost:5173

**Test Manifest Library:**
- Click "Manifests" in the top nav — should see empty library with "No manifests yet" message
- Verify category filter pills (All, Characters, Environment, etc.) are visible
- Verify sort dropdown is visible

**Test Manifest Creator:**
- Click "+ New Manifest" — should navigate to creator form
- Enter name: "Test Characters", description: "A test manifest", category: "CHARACTERS"
- Drag-drop 2 images (any PNG/JPEG) into the upload zone
- Verify: Assets appear below with image thumbnails, editable name/type/description fields, and auto-generated tags (CHAR_01, CHAR_02)
- Change one asset type to "OBJECT" — verify tag becomes OBJ_01
- Click "Save Draft"

**Test Library with Data:**
- Should redirect to library showing the "Test Characters" card
- Verify card shows: name, DRAFT status badge, CHARACTERS category, "2 assets" count
- Click "Duplicate" — verify a "Test Characters (Copy)" appears
- Click "Delete" on the copy — verify confirmation modal, then deletion

**Test Edit Mode:**
- Click "Edit" on the original manifest — should load creator with existing data
- Verify name, description, category, and assets are pre-populated
- Click "Cancel" to return to library
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit` passes
2. Build: `npm run build` succeeds
3. Creator form: Name, description, category, tags fields render and are editable
4. Drag-drop: Dropping images creates assets with thumbnails and editable metadata
5. Asset editing: Name, type, description, tags all editable inline
6. Auto-tagging: Manifest tags (CHAR_01, OBJ_02) auto-assigned based on type
7. Save: "Save Draft" creates/updates manifest with DRAFT status
8. Integration: Creator accessible from Library via "+ New Manifest" and "Edit" actions
</verification>

<success_criteria>
- Manifest Creator supports full Stage 1 workflow (upload + tag, no processing)
- Drag-drop image upload works for PNG, JPEG, WebP up to 10MB
- Each uploaded image is an asset with editable name, type, description, tags
- Manifest tags auto-generated (CHAR_01, OBJ_02, etc.)
- Save creates DRAFT manifest with all assets
- Edit mode loads existing manifest data
- Human verification confirms end-to-end flow works visually
</success_criteria>

<output>
After completion, create `.planning/phases/04-manifest-system-foundation/04-03-SUMMARY.md`
</output>
