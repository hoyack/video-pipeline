---
phase: 03-orchestration-interfaces
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vidpipe/orchestrator/__init__.py
  - vidpipe/orchestrator/state.py
  - vidpipe/orchestrator/pipeline.py
autonomous: true

must_haves:
  truths:
    - "Pipeline follows state machine transitions STORYBOARD -> KEYFRAMES -> VIDEO_GEN -> STITCH -> COMPLETE"
    - "Failed pipeline can resume from last completed step without redoing completed work"
    - "Pipeline run metadata (start time, duration, step log) is tracked in PipelineRun table"
    - "Each step checks database status before executing and skips already-completed work"
  artifacts:
    - path: "vidpipe/orchestrator/__init__.py"
      provides: "Public API exports for orchestrator module"
      contains: "run_pipeline"
    - path: "vidpipe/orchestrator/state.py"
      provides: "State machine transition logic and status constants"
      contains: "PIPELINE_STATES"
    - path: "vidpipe/orchestrator/pipeline.py"
      provides: "Main pipeline orchestrator with idempotent step execution"
      exports: ["run_pipeline"]
      min_lines: 80
  key_links:
    - from: "vidpipe/orchestrator/pipeline.py"
      to: "vidpipe/pipeline/storyboard.py"
      via: "import generate_storyboard"
      pattern: "from vidpipe\\.pipeline\\.storyboard import generate_storyboard"
    - from: "vidpipe/orchestrator/pipeline.py"
      to: "vidpipe/pipeline/keyframes.py"
      via: "import generate_keyframes"
      pattern: "from vidpipe\\.pipeline\\.keyframes import generate_keyframes"
    - from: "vidpipe/orchestrator/pipeline.py"
      to: "vidpipe/pipeline/video_gen.py"
      via: "import generate_videos"
      pattern: "from vidpipe\\.pipeline\\.video_gen import generate_videos"
    - from: "vidpipe/orchestrator/pipeline.py"
      to: "vidpipe/pipeline/stitcher.py"
      via: "import stitch_videos"
      pattern: "from vidpipe\\.pipeline\\.stitcher import stitch_videos"
    - from: "vidpipe/orchestrator/pipeline.py"
      to: "vidpipe/db/models.py"
      via: "PipelineRun tracking"
      pattern: "PipelineRun"
---

<objective>
Implement the pipeline orchestrator with state machine transitions, idempotent resume logic, and run metadata tracking.

Purpose: The orchestrator is the core coordinator that wraps existing pipeline step functions (storyboard, keyframes, video_gen, stitcher) with database state checks for crash recovery. Both CLI and API depend on this module.

Output: `vidpipe/orchestrator/` module with `run_pipeline()` function that executes the full pipeline with resume capability.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-orchestration-interfaces/03-RESEARCH.md

# Existing pipeline function signatures (all take session + project):
# vidpipe/pipeline/storyboard.py: async def generate_storyboard(session: AsyncSession, project: Project) -> None
# vidpipe/pipeline/keyframes.py: async def generate_keyframes(session: AsyncSession, project: Project) -> None
# vidpipe/pipeline/video_gen.py: async def generate_videos(session: AsyncSession, project: Project) -> None
# vidpipe/pipeline/stitcher.py: async def stitch_videos(session: AsyncSession, project: Project) -> None

@vidpipe/db/models.py
@vidpipe/db/__init__.py
@vidpipe/db/engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state machine constants and transition logic</name>
  <files>vidpipe/orchestrator/__init__.py, vidpipe/orchestrator/state.py</files>
  <action>
Create `vidpipe/orchestrator/__init__.py` with exports for `run_pipeline` from pipeline module.

Create `vidpipe/orchestrator/state.py` with:

1. **Status constants** as a module-level dict `PIPELINE_STATES` defining the ordered pipeline states:
   - `"pending"` — initial state after project creation
   - `"storyboarding"` — generating storyboard from prompt
   - `"keyframing"` — generating sequential keyframe images
   - `"video_gen"` — generating video clips via Veo
   - `"stitching"` — concatenating clips into final MP4
   - `"complete"` — pipeline finished successfully
   - `"failed"` — pipeline encountered unrecoverable error

2. **STEP_TRANSITIONS** dict mapping each active status to its next status:
   - `"pending" -> "storyboarding"`
   - `"storyboarding" -> "keyframing"`
   - `"keyframing" -> "video_gen"`
   - `"video_gen" -> "stitching"`
   - `"stitching" -> "complete"`

3. **RESUMABLE_STATES** set containing statuses from which resume is allowed: `{"pending", "failed", "storyboarding", "keyframing", "video_gen", "stitching"}`. NOT "complete".

4. Helper function `can_resume(status: str) -> bool` that checks if status is in RESUMABLE_STATES.

5. Helper function `get_resume_step(status: str) -> str` that returns which step to resume from:
   - `"pending"` or `"storyboarding"` or `"failed"` with no scenes -> resume from `"pending"` (storyboard step)
   - `"keyframing"` or `"failed"` with scenes but incomplete keyframes -> resume from `"keyframing"`
   - `"video_gen"` or `"failed"` with keyframes but incomplete clips -> resume from `"video_gen"`
   - `"stitching"` or `"failed"` with clips -> resume from `"stitching"`

   NOTE: For failed projects, the resume step depends on what was actually completed in the database, not on the status string. The `get_resume_step` function should accept the project status and a `completed_steps` dict (e.g., `{"has_storyboard": bool, "has_keyframes": bool, "has_clips": bool}`) to determine where to resume. When status is "failed", use `completed_steps` to find the right re-entry point.
  </action>
  <verify>
Run `python -c "from vidpipe.orchestrator.state import PIPELINE_STATES, STEP_TRANSITIONS, RESUMABLE_STATES, can_resume, get_resume_step; print('OK')"` succeeds.
  </verify>
  <done>State machine constants defined, transition map complete, resume logic correctly identifies re-entry point based on project status and completed work.</done>
</task>

<task type="auto">
  <name>Task 2: Implement idempotent pipeline orchestrator with run metadata tracking</name>
  <files>vidpipe/orchestrator/pipeline.py</files>
  <action>
Create `vidpipe/orchestrator/pipeline.py` implementing the main `run_pipeline()` function.

**Function signature:** `async def run_pipeline(session: AsyncSession, project_id: uuid.UUID, progress_callback: Optional[Callable[[str], None]] = None) -> None`

The `progress_callback` is an optional callable that receives status messages (e.g., "Generating storyboard..."). CLI uses this for Rich progress updates. API ignores it.

**Implementation pattern (from research Pattern 1 - Idempotent Pipeline Steps):**

1. **Load project** from database by `project_id`. Raise ValueError if not found.

2. **Create PipelineRun record** at start:
   ```python
   run = PipelineRun(project_id=project_id)
   session.add(run)
   await session.commit()
   ```
   Initialize a step_log dict to track timing per step.

3. **Determine resume point** using `get_resume_step()` from state module. Query database to build `completed_steps` dict:
   - `has_storyboard`: project has scenes (count > 0)
   - `has_keyframes`: all scenes have both start and end keyframes
   - `has_clips`: all scenes have completed video clips (status != "pending")

   If project status is "failed", reset it to the resume step status before continuing.

4. **Execute steps sequentially with idempotency checks:**

   **Step 1 - Storyboard** (if status == "pending"):
   - Set `project.status = "storyboarding"`, commit
   - Call `progress_callback("Generating storyboard...")` if provided
   - Call `await generate_storyboard(session, project)`
   - Set `project.status = "keyframing"`, commit
   - Log step duration to step_log

   **Step 2 - Keyframes** (if status in ["pending", "storyboarding", "keyframing"] — i.e., reached this point):
   - Only execute if `project.status == "keyframing"` (which it will be after step 1 or on resume)
   - Call `progress_callback("Generating keyframes...")` if provided
   - Call `await generate_keyframes(session, project)`
   - Set `project.status = "video_gen"`, commit
   - Log step duration

   **Step 3 - Video generation** (if project.status == "video_gen"):
   - Call `progress_callback("Generating video clips...")` if provided
   - Call `await generate_videos(session, project)`
   - Set `project.status = "stitching"`, commit
   - Log step duration

   **Step 4 - Stitching** (if project.status == "stitching"):
   - Call `progress_callback("Stitching final video...")` if provided
   - Call `await stitch_videos(session, project)`
   - Set `project.status = "complete"`, commit
   - Log step duration

5. **Error handling for each step:**
   Wrap each step in try/except. On failure:
   - Set `project.status = "failed"`
   - Set `project.error_message = f"{step_name} failed: {type(e).__name__}: {str(e)}"`
   - Commit the failure state
   - Update PipelineRun with partial duration and step_log
   - Re-raise the exception

6. **Finalize PipelineRun** on success:
   - Set `run.completed_at = datetime.utcnow()`
   - Set `run.total_duration_seconds` from start to end
   - Set `run.log = step_log` (dict with step names as keys, duration in seconds as values)
   - Commit

**Important implementation notes:**
- Use `from vidpipe.pipeline.storyboard import generate_storyboard` etc. (direct imports from pipeline modules)
- The pipeline functions all have signature `(session: AsyncSession, project: Project) -> None`
- After calling each pipeline function, refresh the project from the session since the pipeline functions modify it: `await session.refresh(project)`
- Use `import time` and `time.monotonic()` for step timing (not datetime, which has timezone issues)
- Import `select` from sqlalchemy for database queries
- Import Scene, Keyframe, VideoClip from db.models for checking completed_steps
- Use `logging.getLogger(__name__)` for structured logging of step transitions
  </action>
  <verify>
Run `python -c "from vidpipe.orchestrator.pipeline import run_pipeline; print('OK')"` succeeds. Verify the function accepts (session, project_id, progress_callback) parameters.
  </verify>
  <done>Pipeline orchestrator executes all 4 steps sequentially with idempotency checks, tracks PipelineRun metadata (duration, step log), handles failures with error message persistence, and supports resume from any failed step.</done>
</task>

</tasks>

<verification>
- `python -c "from vidpipe.orchestrator import run_pipeline"` imports successfully
- `python -c "from vidpipe.orchestrator.state import PIPELINE_STATES, STEP_TRANSITIONS, can_resume, get_resume_step"` imports successfully
- State constants include all 7 statuses (pending, storyboarding, keyframing, video_gen, stitching, complete, failed)
- STEP_TRANSITIONS maps 5 active states to their next states
- run_pipeline accepts session, project_id, and optional progress_callback
</verification>

<success_criteria>
The orchestrator module exists with working imports. run_pipeline() wraps all 4 pipeline steps with state machine transitions, idempotent resume logic, error handling with failure state persistence, and PipelineRun metadata tracking. The progress_callback parameter enables CLI progress display without coupling to Rich.
</success_criteria>

<output>
After completion, create `.planning/phases/03-orchestration-interfaces/03-01-SUMMARY.md`
</output>
